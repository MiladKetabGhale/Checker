\documentclass{llncs}
\usepackage{holtexbasic,url,amsmath,environ}
\renewcommand{\HOLinline}[1]{\ensuremath{#1}}
\renewcommand{\HOLKeyword}[1]{\mathsf{#1}}
\renewcommand{\HOLConst}[1]{{\textsf{\upshape #1}}}
\renewcommand{\HOLSymConst}[1]{\HOLConst{#1}}
\NewEnviron{holthmenv}{
  \begin{equation*}
  \begin{array}[t]{l}
  \BODY
  \end{array}
  \end{equation*}}
\newcommand{\TODO}[1]{{\bf TODO:} #1}
\begin{document}
\title{Verified Certificate Checking for Counting Votes}
\author{
Milad~K.~Ghale\inst{1}\and
Dirk~Pattison\inst{1}\and
Ramana~Kumar\inst{2}}
\institute{Australian National University\and
Data61, CSIRO and UNSW}
\maketitle
\begin{abstract}
Abstract goes here
\end{abstract}
\section{Introduction}\label{sec:intro}

Certified computation offers a high level of trustworthiness and correctness of the output end result. 
A Certifying program is an implementation of an algorithm which, upon each execution, produces an  end result accompanied by a certificate as to how it has been computed\cite{}. The certificate witnesses correctness of the computation and is independently and effectively checkable without any reference  to the program producing it. Therefore the verification objective directs to verifying the checker of the certificates rather than the program itself. In contrast to complete static verification methods, this demands much less resources for undertaking the task. Moreover, it considerably reduces the trust that clients has to lay in many components, including the programmer, compiler and hardware malfunctioning.



In recent years, numerous programs have come to carry the task of vote counting based on implementation of some Single Transferable Vote (STV) schemes. STV algorithms are preferential protocols for deciding winners of an election. They aim at reflecting the proportion of the preferences of the public towards different competing candidates. All of these programs are claimed to satisfy the expectations of the protocol. However, there are corner cases in STV protocols that are open to interpretation and, therefore, divergent implementations and computations. Moreover, source code of many of these programs are kept secret under the excuse of \lq\lq commercial in use\rq\rq\cite{} . This in addition to the mentioned difficulties of the traditional verification methods makes it challenging to verify these programs to decide which one(s) indeed implement the algorithm correctly. Hence, reliability of the computations by aforementioned programs requires huge amount of trust. Furthermore, absence of adequate correctness proofs stands in sharp contrast with election qualitative measures such as universal verifiability whose realisation amounts to providing as many scrutineers as possible with a guarantee for authenticity of the election result.

   
A cost-effective solution for verification of such programs is to certify them and then validate the certificate produced upon each execution by a verified checker.  Here, we demonstrate how to carry the task out for STV elections. To this end, we take four steps. 


First, we formalise  vote counting algorithm  inside the theorem prover HOL as a sequence of logical rule applications to stages of the count. Stages of the count, are formalised as typing judgements which are of two kind; non-final and final. The former is constituted of six components that put together provide all the necessary information to know what the current status of the count is. It informs the scrutineers of the ballots which (possibly) need to be counted, tally of each candidate, pile of the votes allocated to each candidate according to the preferences, list of candidates whose votes may be distributed later, and list of elected and continuing candidates at this stage. The latter judgement is a terminal stage of the process whereby winners of the election are announced. A list of judgements is called a \emph{formal certificate}.



Moreover, The election protocol implicitly specifies steps for advancing the counting process. These steps which tell us when and how to move from one stage of the count (judgement) to another are formalised as logical rules. These rules have side conditions that must be met before such transitions can happen. Side conditions are, essentially, the formal counterpart of the protocol laid down by the legislation, and are expressed by standalone HOL predicates. By satisfying these side conditions, one makes sure that the process has proceeded in accordance to the protocol of the election. We shall refer to such assertions as predicative definitions or \emph{specification}. Finally, We specify the checker a disjunction of the predicative counting rules. Therefore to validate a given formal certificate, the checker merely needs to verify if each two consecutive list elements match against a premise and conclusion of a legitimate rule instance application.



Second, We have HOL functions defined for the purpose of performing computation with. Some of these functions are auxiliary computational components which we use to assert computational counterparts of the predicative counting rules. In essence, each computational counting rule is expressed as a conjunction of some of these auxiliary definitions. The computational checker, which certifies a given formal certificate, is formalised a disjunction of the computational counting rules.



Third, we establish correspondence between the predicative definitions and their respective computational definitions. All of the functions which we have defined in the second step and did not exist in HOL libraries are proven correct with respect to their specification laid down in the first step. Therefore, we prove that the computational checker validates a formal certificate if and only if its specification is met. Hence, we only validate a formal certificate when and if it has been obtained in accordance to steps specified by the protocol of the election.  



Our fourth step is extraction of executable that is correct down to the machine code. To accomplish this final step, we first translate our HOL definitions into CakeML equivalents. This process is mostly automatic for the purely functional HOL definitions  and proceeds by calling a CakeML build-in function namely, \textsf{translate}. The \textsf{translate} function translates a given HOL function \textsf{f} and creates a CakeML AST \textsf{f'} which is proven extensionally equivalent to \textsf{f} by the refinement theorem of CakeML. Therefore we are able to uplift whatever properties proved for our HOL computational definitions to CakeML embedded equivalent functions. As a result the computational behaviour of the CakeML translated functions on a formal certificate is the same as their original HOL counterparts. 


Furthermore, to perform computation on an actual certificate, we combine our parser defined in HOL with I/O functions of CakeML, and the computational checker. These are put together as a deeply embedded CakeML function, which is named \textsf{check\_count}. The behaviour of this function is stated as Hoare triples in syle of separation logic. Its behaviour is proven correct with respect to a CakeML formalisation of the characteristic formula, which is a higher-order logic assertion employed to state properties about impure parts of a program. Consequently, we come to verify that \textsf{check\_count} is extensionally equivalent to the computational checker in the HOL. Hence, we validate an actual certificate if and only if its corresponding  formal certificate is valid. Finally to obtain executable code, we evaluate a built-in CakeML function called \textsf{compiler} on our program. There exists a correctness theorem about the compiler itself. We instantiate this theorem with our deeply embedded \textsf{check\_count} program and the theorem proved about its behaviour, to obtain a correctness result on this particular run of the compiler. This result roughly sates that the behaviour of the \textsf{check\_count} on the machine level coincides with its behaviour on the top-level. 

\begin{itemize}
\item to do: write on connecting CakeML with HOL and the parser. Here we will explain proof of correspondence between valid certificates and valid judgements. The connection between checker as in HOL with loop function in CakeML. Some internal processes of translation from HOL to CakemL is to be given in a simple yet packed-up language.
\item
to do: tests of the executable. Here tests on the certificates output by counting programs is to be presented. The tests should reflect complexity of the computation with regards to number of ballots, candidates, and number of seats.
\item to do: reviewing related works. This one is almost right away. But will look to see if there is more to mention.
\end{itemize}



\section{Outline}\label{sec:out}

\noindent
Certificable / Verifiable Computation.
\begin{itemize}
  \item programs produce results with correctness proofs
  \item much easier than, and orthogonal to, verification
  \item however need to prove that valid certificates imply valid
  results (soundness), maybe also that every correct result is
  certifiable.
  \item in particular, this is independent of the program that
  produces the results.
  \item mainly used to offload computation to untrusted clients.
  \item reliability is given by verifying the \emph{checker} rather
  than the program that carries out computation.
\end{itemize}

\noindent
Vote counting.

\begin{itemize}
  \item here, we employ certified computation with a different goal:
  vote counting
  \item difference: general public / election authority is outsourcing
  computation to us.
  \item state of the art: no verifiability, black box, sometimes not
  even open source.
  \item this is a real problem -- e.g. NSW 2012 Griffith
  \item large trust base, including to trust that the right program
  has been run!
  \item indeed in evoting research: concept of ``universal
  verifiability'' means precisely that. Is the holy grail of any
  evoting system.
  \item for vote counting, this is a paradigm shift: don't verify
  the program, but verify the checker -- down to machine level!
  \item this happens in a fully verified / verifiable environment
  \item higher guarantees by machine level verification
\end{itemize}

\noindent
Our contribution.
\begin{itemize}
  \item Have formalised STV (complex, preferential voting scheme
  used in Malta, Scotland, etc.) in HOL
  \item rule based to minimise gap between law and code
  \item Have designed a notion of certificate that establishes the
  correctness of STV counts. Think about this more \dots
  \item Have developed a verified checker
  \item Used CakeML to give correctness down to machine level
  \item smallest possible trust base: microprocessor, basic IO
  system calls
\end{itemize}


\section{Single Transferable Vote and Certification}

\section{Final Theorem}
\begin{holthmenv}
  \HOLthm[width=80]{check_countProof.check_count_compiled_thm}
\end{holthmenv}

\begin{holthmenv}
  \HOLthm[def,width=90]{check_countProg.Check_Certificate_def}
\end{holthmenv}

\section{Evaluation}
\begin{itemize}
  \item to be done.
\end{itemize}

\section{Related Work}
\begin{itemize}
  \item Verifiability and electronic voting
  \item Verified / certified computation in general
  \item CakeML stuff??

\end{itemize}

\section{Conclusion}

\bibliographystyle{splncs03}
\bibliography{paper}
\end{document}
% vim: ft=tex
