\documentclass{llncs}
\usepackage{etoolbox}
\usepackage{wrapfig}
\usepackage{graphicx}
\usepackage{bussproofs}
\usepackage{holtexbasic,url,amsmath,environ}
\renewcommand{\HOLTokenTurnstile}{\ensuremath{\vdash\!\!}}
\renewcommand{\HOLinline}[1]{\ensuremath{#1}}
\renewcommand{\HOLKeyword}[1]{\mathsf{#1}}
\renewcommand{\HOLConst}[1]{{\textsf{\upshape #1}}}
\renewcommand{\HOLTyOp}[1]{\textsf{\itshape #1}}
\renewcommand{\HOLSymConst}[1]{\HOLConst{#1}}
\renewcommand{\HOLTokenBar}{\ensuremath{\mathtt{|}}}

\ifdef{\dpspecial}{
%% tmp by Dirk
\newcommand{\HOLtm}[1]{\texttt{#1}}
\newcommand{\HOLty}[1]{\texttt{#1}}
\newcommand{\HOLthm}[2][]{\texttt{#2}}
}{}
\NewEnviron{holthmenv}{
  \begin{equation*}
  \begin{array}[t]{l}
  \BODY
  \end{array}
  \end{equation*}}
\newcommand{\TODO}[1]{{\bf TODO:} #1}
\begin{document}
\title{Verified Certificate Checking for Counting Votes}
\author{
Milad~K.~Ghale\inst{1}\and
Dirk~Pattinson\inst{1}\and
Ramana~Kumar\inst{2}}
\institute{Australian National University\and
Data61, CSIRO and UNSW}
\maketitle
\begin{abstract}
We introduce a new framework for verifying electronic vote counting results that are based on the Single Transferable Vote scheme (STV). Our approach frames electronic vote counting as a certified computation where each execution of the counting algorithm is accompanied by a certificate that witnesses the correctness of the output. These certificates are then checked for correctness independently of the means employed to produce them. In particular, we advocate to verify the verifier rather than the software used to produce the result. We use the theorem prover HOL to formalise the counting protocol of an STV scheme to obtain full static verification of the checker. By means of built-in mechanisms that connect HOL with the verified CakeML compiler, we then extract an executable that is computationally equivalent to the verified verifier. The executable machine code is guaranteed to behave correctly with respect to the formalised specification of the protocol. Moreover, it can check certificates of real-size elections efficiently. Our encoding is modular, so repeating the same process for another different STV scheme would require a minimal amount of additional work.
\end{abstract}
\section{Introduction}\label{sec:intro}

The main contribution of this paper is a new framework for
verifiably correct vote counting.
%
Electronic voting is becoming more and more prevalent worldwide.
But almost scandalously,
the current state of affairs leaves much
to be
desired, given that the public vote is a cornerstone of
modern democracy.
Indeed electronic techniques as they are used now may be seen as a step back from traditional
paper based elections.

For example, the vote counting software that is used in Australia's
most populous
state, the state of New South Wales,
was found to contain errors that had an impact in at least one seat that
was wrongly filled with high probability.
This was not only reported in specialist publications
\cite{Conway:2017:ANS} but
also in the national press \cite{Brooks:2017:NCE}.

When counting ballots by hand,  the counting is monitored by
scrutineers, usually members of the general public or stakeholders
such as party representatives and members of the general public.
%
In contrast,  computer software that is used to count ballots
merely produces a final result. Moreover, in many cases, the source
code of these programs is commercial in confidence, and there is no
evidence of the correctness of the count that could be seen as
analogous to scrutineers in traditional, paper-based vote counting.

It is universally recognised that transparent and verifiable vote
counting is a key constituent to
establish trustworthiness, and subsequently trust, in the final outcome.
The computer-based methods
currently in use fail to meet both expectations.

In the literature on electronic voting, the notion of \emph{universal
verifiability} of vote counting (any voter can check that the
announced result is correct on the basis of the published ballots
\cite{Kremer:2010:EVE}) has long been recognised as being
central,
both for guaranteeing  correctness, and building trust,
in electronic elections. For vote-counting (on which we focus in
this paper), verifiability means that every stakeholder, or indeed
any
member of the general public, has the means to check that the
computation
of election winners is correct, independently of how the result has
been produced.

The approach presented here combines the concept of certifying
algorithms \cite{DBLP:journals/csr/McConnellMNS11} with formal specification and
theorem proving to address this challenge. In a nutshell, a
\emph{certifying algorithm} is an algorithm that produces, with
every execution, an easily-verifiable certificate of the correctness
of the computed result.  This certificate can then be scrutinised by
a verifier, independently of the tools, hardware or software that
were used to create the certificate.

Our focus in this paper is on the \emph{verifier}. We briefly
discuss a
concise formal specification of \emph{single transferable vote} (STV), a
complex, preferential voting system used e.g. in Ireland, Malta, New
Zealand and Australia for multi-seat constituencies. From this specification, we develop a notion
of \emph{certificate} so that correct certificates guarantee
correctness of election results. The main body of our work concerns
the \emph{verifier} (certificate checker), and we present a
synthesis of the verifier that is itself fully verified down to the
machine-code level.


This proceeds in four steps.
First, we formalise  the vote counting protocol as a sequence of
steps inside the HOL theorem prover where every step
corresponds to an action taken by a counting officer in a
paper-based setting.  There are two kinds of stages that we call
\emph{judgements} in analogy to typing assertions in type theory.
\HOLtm{Final} judgements just declare the set of winners.
\HOLtm{NonFinal} judgements represent the current state of the count
as a tuple, corresponding to a snapshot of the stage
of the count in a paper-based setting.  The formalisation of the
voting protocol then takes the form of \emph{rules} that specify how
to advance from one judgement to the next, thereby advancing the
count. The applicability of particular rules are described
by side conditions that are in turn formalised by HOL predicates.  A
correct certificate is then simply a sequence of judgements where
each judgement is justified through its predecessor by means of a
correct rule application.  The task of the verifier is then simply
to process a list of judgements and ascertain that this is indeed
the case.  In particular, our specification of rules is purely
logical.


Second, in tandem with the logical specification of each rule, we
define a Boolean-valued function that checks whether or not the rule has
been applied correctly.  This then directly gives rise to the
verifier that, at every step, just checks whether any of the rules
is applicable, using the corresponding Boolean-valued function.

Third, we establish correspondence between the logical
definitions and their computational counterparts. This boils
down to formally establishing that the logical specification holds
if and only if the Boolean-valued function returns true, which in
turn implies the correctness of the certificate verifier.
This allows us to conclude that a valid certificate indeed
implies that the election protocol has been carried out in
accordance to the specification.


In the fourth, and last step, we synthesise an implementation of  the verifier and produce a proof this implementation's correctness.  This is
achieved by using proof-producing synthesis~\cite{JFP14} of CakeML code from the HOL definitions, then using the verified CakeML compiler~\cite{DBLP:conf/icfp/TanMKFON16} to produce the machine code.
To perform computation on an actual certificate, we define the formal
syntax for certificates, and a parser in HOL, that we combine with the
I/O mechanisms of CakeML to obtain the verifier.
The result is an executable verifier that provably validates a
certificate if and only if the certificate witnesses a correct
execution of the vote counting protocol.

In summary, our slogan is ``verify the verifier''. Rather than
verifying the \emph{program} that performs an election count, we
demand that a program produces a certificate that we can then
independently verify. This has several advantages. For one, it is
much less labour intensive to verify the verifier, compared with
verifying the counting program. Second, having verifiable certificates at hand
meets the goal of universal verifiability~\cite{DBLP:conf/esorics/KremerRS10}.
Third, we achieve correctness over a minimal trust base through the
use of CakeML.

In the remainder of the paper, we describe our framework in detail
and demonstrate that it can handle real-world size elections by
evaluating it on historical data of elections conducted in
Australia.



\section{The Protocol and its HOL Formalisation}
Single Transferable Vote is a preferential voting scheme that is
used in multi-seat constituencies. Voters rank (possibly
a subset of) candidates by assigning numerical preferences to
candidates as in
\begin{wrapfigure}{r}[0cm]{0.4\textwidth}
  \begin{center}
    %\raisebox{0pt}[-1cm]
    \raisebox{0pt}[\dimexpr\height-2.5\baselineskip\relax]
    {\includegraphics[width=0.37\textwidth]{ballot.png}}
    \vspace*{-8ex}
    %\raisebox{0pt}[\dimexpr\height-8.5\baselineskip\relax]{xx}
    %\includegraphics[width=4cm]{ballot.png}
  \end{center}
\end{wrapfigure}
the ballot on the right, where no two candidates may be given the
same preference. This allows us to represent ballots as duplicate
free lists of candidates where the list order reflects the
preference order.

Each election defines a \emph{quota}, i.e. a minimal set of votes
that a candidate must receive in order to be elected. The count
starts by counting all voters' \emph{first preferences}, and
candidates who reach the quota are elected, but more often than not,
there will still be seats to fill.  This is effected by two
mechanisms:
\begin{enumerate}
  \item Transfer of surplus votes. Votes for elected candidates in
excess of the quota are distributed to (and counted in favour of)
the next preference listed on the ballot.
  \item Elimination of candidates. The candidate with the
\emph{least} number of first preferences is eliminated from the
election, and their votes are then distributed to the next listed
preference on the ballot.
\end{enumerate}

\noindent
We give a precise definition of STV below. The main idea of
distributing surplus votes is to account for \emph{additional}
candidates favoured by a voter if their first preference is already
elected, whereas elimination honours voters'
follow-on preferences if their first preference \emph{cannot} be
elected.  Of course, the key question is precisely which ballots
should be considered surplus and distributed to the next preferences, as follow-on preferences will
generally differ. This is the purpose of a third mechanism:

\begin{enumerate}
\setcounter{enumi}{2}
\item Fractional Transfer. \emph{All} suprlus votes are transfered
to the next preference, but at a \emph{reduced} weight that is
proportional to the size of the surplus.
\end{enumerate}

\noindent
For example, if a candidate exceeds the quota by 20\%, all first
preference votes for that candidate are re-assigned a weight of
$0.2$ and re-injected into the count, and regarded as
first-preference votes for the subsequently listed candidate. In
other words, the number of first preference votes for a candidate is
the sum of the \emph{weights} of ballots where that candidate is
listed as first preference. The initial weight of all ballots is
$1$.

There are various versions of STV. They mainly differ in how  and
when ballots are transferred and candidates are elected, the
calculation of the transfer value, and the various tie breaking
methods used to determine which candidate is to be excluded.
Here, we deal with a generic version of STV that
incorporates all three mechanisms outlined above, and is very
similar to the method used to elect members of the Australian
Senate, and incidentally also to the scheme used elect the representatives of the
student's union of the first and second author. Design decisions in
the precise formulation of the scheme are resolved as follows:

\begin{description}
\item[Step-by-step surplus transfer.] Surplus votes of
elected candidates that have exceeded the quota  are transferred
in order of number of first preferences received.  That is, surplus
votes of the candidate with the largest number of first preferences
are transferred first.
\item[Electing after each transfer.] After each
transfer of surpluses, candidates that reach the quota after
surplus votes are being elected immediately.
\end{description}


\noindent
The description of the formal protocol that we are analysing uses
the following terminology. A \emph{continuing candidate} is a
candidate that has neither been elected nor eliminated.
The \emph{first preference} of a
ballot is the most preferred continuing candidate, and the
\emph{transfer value} of a ballot is the fractional weight of a
ballot. We keep track of the following data throughout:
\begin{itemize}
  \item the set of \emph{uncounted ballots}
  \item a \emph{tally} for each candidate, the sum of the transfer
values of all ballots counted in the candidate's favour
  \item a \emph{pile} for each candidate that contains all ballots
counted in favour of the respective candidate
  \item an  queue of candidates that await surplus transfer
\end{itemize}
Initially, the queue for surplus transfer, as well as the piles
associated to the individual candidates are empty, all ballots are
uncounted, and all
candidates are continuing.
From this initial state, the protocol proceeds as follows:
\begin{center} \begin{enumerate}
\item determine the set of \emph{formal} ballots, i.e. those ballots
that represent a total order of preferences over a subset of
candidates, each of which receives an initial transfer value of $1$.
\item determine the number of first preference votes (the tally) for each
continuing candidate. In doing this, record which vote is counted for which
candidate by adding the ballot paper to the respective pile.
\item if there are unfilled seats, all
candidates that have reached the quota are elected, and are added to
the transfer
queue  in order of their tally
\item if all the vacancies have been filled, counting terminates and the result
is announced.
\item if the number of unfilled vacancies equals or exceeds the number
of continuing candidates, all continuing candidates are elected and the
result is announced.
\item if there are still vacancies, all ballots are counted, and the
transfer queue is not empty, remove the first candidate from the
transfer queue and transfer their votes (the votes on their pile)
to the next preference by declaring these votes to be uncounted and
the transfer value given by

\begin{equation}  \label{eq:tv} \mbox{new value} =
\frac{\mbox{number of votes of elected candidate} -
\mbox{quota}}{\mbox{number of votes of elected candidate}}
\end{equation}

\noindent Subsequent transfer values are computed as the product of
the current value with previous transfer value.
\item if there are
still vacancies, all ballots are counted, and all surplus votes
are transferred, choose the candidate with the least amount of first
preference votes and exclude that candidate from the set of
continuing candidates. All votes counted in favour of the eliminated
candidate are transferred to the next preference (with unchanged
transfer value).
\end{enumerate} \end{center}

\subsection{An Example Certificate}

As argued in the introduction, in the framework of certified
computation, each step of the protocol is evidenced. Each of the
steps outlined above is formalised as a rule that progresses the
count. Rules have side conditions (e.g. candidates having reached
the quota, or all ballots being counted) and rule application
changes the data that we track throughout the count (e.g. updating
the tally, or removing a candidate from the set of continuing
candidates). We given an example certificate in
Figure~\ref{fig;figure}.
Here, we have a
small election
with three candidates $A$, $B$ and $C$, and an initial set of
ballots containing
$b_1=([A,C],1)$, $b_2=([A,B,C],1)$, $b_3=([A,C,B],1)$,
$b_4=([B,A],1)$, $b_5=([C,B,A],1)$.  Each ballot is a pair, where
the first component is a preference-ordered list of candidates, and
the second is the transfer value (initially set to $1$). The
certificate consists of a \emph{header} that specifies the quota as
a fraction, the number of seats to be filled, and the list of
candidates being voted on.
The fourth line is the election result, and the remainder of the
certificate consists of the intermediate steps that lead to this
outcome.
\begin{small} \begin{figure}[b]
\begin{tabular}{c@{\hspace{2cm}}c} \AxiomC{\tiny 133\%50} \noLine
\UnaryInfC{\tiny 2} \noLine \UnaryInfC{\tiny $[A,B,C]$} \noLine
\UnaryInfC{\scriptsize [A,C]} \RightLabel{\tiny hwin}
\UnaryInfC{\tiny []; A[3\%1] B[111\%100] C[133\%100]; A[] B[]
C[$b_{5}$,([C],11\%),([C,B],11\%100),([C],11\%100)]; []; [A]; [C]}
\RightLabel{\tiny count} \UnaryInfC{\tiny [$b_4$,([B,C],0.11)];
A[3\%1] B[111\%100] C[122\%100], A[] B[$b_4$,([B,C],11\%100)]
C[$b_{5}$,([C],11\%100),([C,B],11\%100)];[];[A];[C]}
\RightLabel{\tiny elim} \UnaryInfC{\tiny []; A[3\%1] B[111\%100]
C[122\%100], A[] B[$b_4$,([B,C],11\%100)]
C[$b_5$,([C],11\%100),([C,B],113\%1000)]; []; [A]; [B,C]}
\RightLabel{\tiny count} \UnaryInfC{\tiny
[([A,C],11\%100),([A,B,C],11\%100),([A,C,B],11\%100)]; A[3\%1]
B[1\%1] C[1\%1]; A[] B[$b_4$] C[$b_5$]; []; [A]; [B,C]}
\RightLabel{\tiny transfer} \UnaryInfC{\tiny []; A[3\%1] B[1\%1]
C[1\%1]; A[([A,C],11\%100),([A,B,C],11\%100),([A,C,B],11\%100)]
B[$b_4$] C[$b_5$]; [A]; [A]; [B,C]} \RightLabel{\tiny elect}
\UnaryInfC{\tiny []; A[3\%1] B[1\%1] C[1\%1]; A[$b_1$,$b_2$,$b_3$]
B[$b_4$] C[$b_5$]; []; []; [A,B,C]} \RightLabel{\tiny count}
\UnaryInfC{\tiny ba; A[0\%1] B[0\%1] C[0\%51]; A[] B[] C[]; []; [];
[A,B,C]} \DisplayProof \end{tabular} \caption{Example
Certificate} \label{fig;figure} \end{figure} \end{small}

The certificate records every step of the count, where a step
corresponds to a rule application, where the rules themselves are
modelled on valid actions that of counting officers to progress the
count. The inspection of a certificate therefore corresponds to
witnessing all the individual steps that take place in a
hypothetical counting station.

Intermediate stages of the count record six pieces of information,
separated by semicolons:  the ballots the are still to be counted,
the tallies of all candidates, the ballots counted in favour of each
candidate, the transfer queue, and finally the sets of continuing
and elected candidates. We briefly illustrate the protocol using the
certificate in Figure \ref{fig;figure} as an example, going though
the protocol step-by-step.


\begin{description}
\item[count.] First preferences for each candidates are computed,
and ballots counted in favour of particular candidates are placed
onto that candidate's pile. Here, $A$ is the first preference on
$b_1$, $b_2$, and $b_3$ (leading to a tally of 3), and $B$ receives $b_4$, and
C receives $b_5$. Tallies are updated so that tally of A becomes
$3$, and B and C each reach $1$.
\item[elect.] Candidate A exceeds the quota, and is elected. The
transfer value of all ballots counted in $A$'s favour  changes to
$11/100$ according to formula (\ref{eq:tv}). The updated pile of A
reflects this change in transfer values, and now contains
$([A,C],11/100)$, $([A,B,C],11/100)$, and $([A,C,B],11/100)$. The data
associated with $B$ and $C$ doesn't change.
\item[transfer.] As there are vacancies and no one else has reached
or exceeded the quota, the surplus of A is dealt with. The list of
uncounted ballots is updated to contain the votes for $A$ (with
transfer values updated in the previous step).
\item[count.] As there are uncounted ballots (again), tallies are
updated. As $A$ is no longer a continuing candidate, the votes are
counted in favour of the highest-ranked continuing candidate.
That is, C receives  two new votes (each of value $11/100$) which
are $([C],11/100)$ and $([C,B],113/1000)$. Candidate B receives one vote,
which is $([B,C],11/1000)$.
\item[elim.] No continuing candidate has reached the quota, one
vacancy is still unfilled, and all ballots are (again) counted.
Hence the candidate with the lowest tally is eliminated (in this
case, $B$) and their votes (with unchanged transfer values) are
again injected into the count.
\item[count.] Candidate C receives one more vote: the vote $([C],11/100)$ from the
excluded candidate B.
\item[hwin.] The only continuing candidate, that is C, is elected and as we have filled all the vacancies, a final stage has been obtained.
\end{description}

\texttt{DP: Why isn't $C$ elected immediately after $B$ is
eliminated?}

\noindent
To validate certificates of this form, we first parse the textual
representation into actual data structures, and then check the
certificates for correctness on the basis of a HOL formalisation
that we now describe.

\subsection{The HOL Formalisation}

Elections are \emph{parameterised} by the data in the header
(candidates, quota and number of vacancies) that remain constant
throughout the count. We use the term \emph{judgement} for the data-structure representation of
the various stages of the count.  They come in two flavours: final
judgements announce the winners, and non-final judgements are
intermediate stages of the execution of the protocol.

\begin{definition}[Judgements]
We formalise judgements as a datatype with two constructors. The
first constructor, \HOLtm{Final w} represents a final stage of the
computation, where $w$ is the final list consisting of all of the
declared elected candidates. The second constructor,
\HOLtm{NonFinal (ba,t,p,bl,e,h)} is an intermediate stage of the
computation, where $\mathit{ba}$ is the list of uncounted ballots at this
point, $t$ is the tally list recording the number of votes of each
candidate has received up to this point, $p$ is the pile list of
votes assigned to each candidate, $\mathit{bl}$ is the list of elected whose
surplus have not yet been transferred, $e$ is the list of elected
candidates by this point, and $h$ is the list of continuing
(hopeful) candidates up to this stage.
\end{definition}

\noindent
Definition~\ref{jud:hol} below gives our straight forward HOL
encoding of judgements. We use lists (instead of sets, or multisets)
mainly for convenience of formalisation in HOL, but this is not used
in an essential way either in the definition, or in the
formalisation, of the counting rules that we give later.
By choosing to
formalise the tally and pile as lists rather than functions
operating on the list of candidates, judgements become an instance
of the equality type class which we use later on in specification
and reasoning about counting rules. Additionally, this formulation
reduces the gap between an actual certificate and its abstract
syntactic representation which we refer to as a \emph{formal
certificate} that is simply a list of judgements.

\texttt{DP: the distinction between actual and formal is not clear.
Remove?}
\begin{definition}\label{jud:hol}
  Assume \HOLty{:ballots}, \HOLty{:tallies}, and \HOLty{:piles} are type synonyms for
  \HOLty[-ballots,-alist]{:ballots},
  \HOLty[-tallies,-alist]{:tallies}, and
  \HOLty[-piles,-alist]{:piles} respectively.
\begin{holthmenv}
\HOLthm[width=80]{CheckerSpec.datatype_judgement}
\end{holthmenv}
\end{definition}

\noindent
As a certificate consists of a sequence of judgements, each of
which represents a state of the count, we need to verify the
correctness of the transitions between successive judgements.
Each rule consists of three main components:
\begin{itemize}
  \item a specification of how premiss and conclusion relate
  \item a side condition that specifies when a rule is applicable
  \item a number of implicit assertions that guarantee the integrity
of the data.
\end{itemize}

\texttt{DP: concrete example here?}

\noindent
For example, we expect a valid certificate to have no duplication in
the list of elected or continuing candidates, and every candidate
must have only one tally and one pile at every non-final judgement.

Crucially, the specification of the counting rules is purely
\emph{descriptive}. To effectively check certificates, we augment
each (specifiaction of a) rule with an actual decision procedure
that, given two judgements, returns either true or false, depending
on whether the rule is applicable or not. The decision procedure and
the formal specification are connected by (formal) proofs of
soundess and completeness, as shown in the figure below.

\includegraphics[scale=0.35]{spec-dec-cropped.pdf}

\noindent
Here, \emph{soundness} refers to the fact that the decision
procedure only stipulates that a rule has been correctly applied if
the application is in accordance with the specification and
\emph{completeness} says that this will happen whenever the rule is
applicable. The decision procedures are actual functions in HOL that
we then translate and extract using CakeML to guarantee
machine-level correctness, and both soundness and completeness are
established formally in HOL. We illustrate this in detail with the
elimination rule.


% \subsection{The Case of the Elimination Rule}

\paragraph{Integrity Constraints.} The integrity constraints for the
elimination rule are identical to those of other rules.
For example, the name of each candidate appears only once in the
initial list of competing candidates. Also, all candidates need to
have precisely one tally and one unique associated pile (of votes
counted in their favour).
For instance, the predicate
\HOLtm{Valid_Init_CandList} restricts legal initial lists of
candidates to those which are non-empty and have no duplicate.
\begin{holthmenv}
  \HOLthm[def,width=80]{CheckerSpec.Valid_Init_CandList_def}
\end{holthmenv}
Moreover, at every stage of the count, every candidate has exactly
one tally and one pile. Therefore, if a judgement in a certificate
maliciously allocates more than one tally to a single candidate, the
bug is detected and the certificate rejected as invalid.  We express
this condition as follows.
\begin{holthmenv}
  \HOLthm[def,width=80]{CheckerSpec.Valid_PileTally_def}
\end{holthmenv}
\noindent
Both predicates are paired with computational twins, and soundness
and completeness connect both.  Here,
given lists $t$ and $l$, the function \HOLtm{Valid_PileTally_dec1} decides if every first element of each pair in $t$ is a member of $l$.
\begin{holthmenv}
  \HOLthm[def,width=80]{Checker.Valid_PileTally_dec1_def}
\end{holthmenv}
Additionally, the function \HOLtm{Valid_PileTally_dec2} determines if each element of $l$ appears as the first component of a pair in $t$.
\begin{holthmenv}
  \HOLthm[def,width=80]{Checker.Valid_PileTally_dec2_def}
\end{holthmenv}
We prove that the formal specification \HOLtm{Valid_PileTally} enforces correctness of the function \HOLtm{Valid_PileTally_dec1}.
\begin{holthmenv}
  \HOLthm[width=80]{CheckerProof.PileTally_to_PileTally_DEC1}
\end{holthmenv}
\noindent
Also the specification \HOLtm{Valid_PileTally} implies correctness of \HOLtm{Valid_PileTally_dec2} witnessed by the theorem below.
\begin{holthmenv}
  \HOLthm[width=80]{CheckerProof.PileTally_to_PileTally_DEC2}
\end{holthmenv}
Conversely, correctness of the computational definition \HOLtm{Valid_PileTally_dec1} and \HOLtm{Valid_PileTally_dec2} entails their respective specifications.
Therefore, we obtain a perfect match between the specification and computational condition for tallies and piles to be distinctively allocated to candidates.

For elimination of the candidate with the smallest tally (number of
first preferences), the protocol states that:
the protocol states that
\begin{small}
\begin{center}
\begin{minipage}{10cm}
\emph{choose the candidate with the least amount of votes and exclude
them from the list of continuing candidates}.
\end{minipage}
\end{center}
\end{small}

We formulate the elimination rule with an additional parameter --
the candidate $c$ to be eliminated.

\paragraph{Side Conditions.} For the elimination rule to be applied
correctly, we stipulate that
\begin{itemize}
  \item the candidate $c$ to be eliminated is indeed a continuing
  candidate
  \item the tally of the candidate to be eliminated is minimal.
  \item all votes are counted, and
  \item there are no pending transfers.
\end{itemize}

The fact that the candidate to be removed is indeed the weakest is established
by another assertion which is part of the side condition.


\paragraph{Relation between Premiss and Conclusion.} If candidate
$c$ is to be eliminated, and their votes are to be transferred to
the next preference, the data captured by premiss and conclusion
needs to change in the following way:
\begin{itemize}
  \item the set of continuing candidates in the \emph{conclusion} is
  the same as in the premiss, with the exception that $c$ is no
  longer continuing
  \item the ballots counted in favour of $c$ (i.e. those on $c$'s
  pile) are re-injected into the count, i.e. placed onto the stack
  of ballots that are to be counted (again).
\end{itemize}

 The predicate \textsf{equal\_except} formally asserts when two lists are equal except for one exact element.
\begin{holthmenv}
  \HOLthm[def,width=80]{CheckerSpec.equal_except_def}
\end{holthmenv}
The computational twin of this definition decides whether
two list match with the exception of one element.  This is the
function \textsf{equal\_except\_dec}.
\begin{holthmenv}
  \HOLthm[def,width=80]{Checker.equal_except_dec_def}
\end{holthmenv}
We formally establish that this function implements
the specification given by the \textsf{equal\_except} predicate.
\begin{holthmenv}
  \HOLthm[width=80]{CheckerProof.EQE_REMOVE_ONE_CAND}
\end{holthmenv}
Moreover, modulo extensional equality, the function \textsf{equal\_except\_dec} is unique.
 \begin{holthmenv}
  \HOLthm[width=80]{CheckerProof.EQE_IMP_REMOVE_ONE_CAND}
\end{holthmenv}

Having defined the implicit integrity constraints, and the
explicit side conditions in the definition of \emph{elimination}, we
can present the formalisation of this rule in HOL as a predicate.
\begin{holthmenv}
  \HOLthm[def,width=85]{CheckerSpec.ELIM_CAND_def}
\end{holthmenv}


The \textsf{ELIM\_CAND} rule is defined on three kind of input; a candidate, a triple composed of three fixed parameters which are the quota, vacancies, and the initial list of candidates, and two judgements one of which is the premise and the other is the conclusion of the rule. Each of the conjuncts corresponds to a condition specified in the definition~\ref{elim:rule}, as we already demonstrated it for a few cases. \textsf{ELIM\_CAND\_dec} is the computational realisation of the \textsf{ELIM\_CAND}.
\begin{holthmenv}
  \HOLthm[def,width=88]{Checker.ELIM_CAND_dec_def}
\end{holthmenv}
We already have demonstrated how the specification of the predicative assertions imply  correctness of the corresponding computational parts. By drawing on these theorems we obtain equivalence of the computational \textsf{ELIM\_CAND\_dec} with its specification \textsf{ELIM\_CAND}. The same procedure is followed to achieve formal specification,  computational definitions, and their correspondence for the rest of counting rules.


\subsection{The Certificate Verifier}

Clearly, one way to verify the result of a computation is to simply
re-compute (possibly using a verified
program)~\cite{DBLP:conf/stoc/BlumK89}. While this makes
perfect sense for a \emph{deterministic} program, voting protocols
generally employ tie-breaking techniques that lead to
non-determinism. In the case of STV, this for example applies when
two candidates are tied for exclusion where it is permissible to
eliminate \emph{either} of the candidates.

From the perspective of certified computation, this is a non-issue,
as the certificate simply records which choice has been made (and
why this choice is permissible). Compared to simply re-computing,
the verification of a certificate provides another significant
advantage: in case of diverging results, we gain information
on precisely what step of the (incorrect) computation is to blame
for the wrong result.

Computationally, the additional advantage is simplicity and speed:  the
verification of the verifier is considerably
simpler than that of a fully-fledged implementation, and certificate
checking is also generally faster than re-computing.

The verification of certificates comprises the following steps.
We need to validate whether the first
judgement of the certificate is a valid initial state of the count,
and whether transitions from one judgement to the next is according to
one of the rules that define the count.
We can therefore check whether a transition from one judgement to
the next is correct by simply considering the disjunction of all
rules, and similarly obtain a computational version from the
individual decision procedures associated with the counting rules.

\begin{holthmenv}
  \HOLthm[def,width=80]{CheckerSpec.valid_judgements_def}
\end{holthmenv}

\noindent
A valid initial judgement is one
where candidate's tally is zero, their
piles are empty, and both the transfer queue and the list of elected candidates
are both empty as well.
\begin{holthmenv}
  \HOLthm[width=80,def]{CheckerSpec.initial_judgement_def}
\end{holthmenv}
Putting this together with the specification of a valid sequence of judgements, we obtain the specification for a valid certificate:
\begin{holthmenv}
  \HOLthm[def,width=80]{CheckerSpec.valid_certificate_def}
\end{holthmenv}
For checking a formal certificate we therefore first  certify if the
certificate starts at an initial stage. Then recursively we continue
checking if transitions have happened correctly, and if the
terminating state is a final one where winners are declared.

The above specification of the checker, corresponds to the following computational formal certificate checker.
\begin{holthmenv}
  \HOLthm[def,width=80]{Checker.Check_Parsed_Certificate_def}
\end{holthmenv}
The correctness of this definition rests on the equivalences we have already established between the specifications and their computational counterparts, namely, \HOLthm[tt]{CheckerProof.initial_judgement_thm} and \HOLthm[tt]{CheckerProof.valid_judgements_thm}.
Consequently a formal certificate is validated if and only if it is valid according to
the HOL specification of \HOLtm{valid_certificate}.
Since the HOL specification realises the protocol, a formal certificate is validated if and only if it meets the protocol's expectation.


\section{Translation into CakeML and Code Extraction}

The verified certificate-checking function, \HOLtm{Check_Parsed_Certificate}, described above, is a good starting point for a verifier, but it has two drawbacks: it is a function in logic rather than an executable program, and relatedly, its input arguments must be provided as values in the correct types (parameters, and a list of judgements).
In this section, we show how we overcome these drawbacks and obtain a verified executable for checking certficates.
Our final theorem about the verifier executable is presented at the end of this section.

\paragraph{Parsing}
The input to the verifier is a textual certificate file, in a format similar to Figure~\ref{fig;figure}.
We specify this file format indirectly, by defining an executable specification of a certificate parser.
Specifically, we define functions that take a string representing a line in the file and return either \HOLtm{NONE} or \HOLtm{SOME (x:unit)}, where \HOLtm{x} is the parsed information from the line.
Given these parsing functions --- \HOLtm{parse_quota}, \HOLtm{parse_seats}, etc. --- we write the verifier as a function, shown below, that operates on lines from a file and calls \HOLtm{Check_Parsed_Certificate} from before to do the actual verification:
\begin{holthmenv}
  \HOLthm[def,width=90]{check_countProg.Check_Certificate_def}
\end{holthmenv}

\paragraph{Translation into CakeML and I/O Wrapper}
Using prior work on proof-producing synthesis~\cite{JFP14} we can automatically synthesise an implementation of the function \HOLtm{Check_Parsed_Certificate} in the programming language CakeML.
The synthesis tool for CakeML produces a theorem relating the semantics of the synthesised program back to the logical function.
However, this implementation is a \emph{pure} function that expects the lines of a file as input.
To actually open the file and read lines from it, we write an impure wrapper (making use of the CakeML Basis Library) around the pure function, and verify the wrapper using Characteristic Formulae for CakeML, as described by Gu\'eneau et al.~\cite{DBLP:conf/esop/GueneauMKN17}.
The result is a complete CakeML program whose I/O semantics is verified to implement the certificate-checking logical function.

\paragraph{Compilation in Logic}
Finally, we would like an executable verifier in machine code (rather than CakeML code).
To produce this, we use the verifed CakeML compiler~\cite{DBLP:conf/icfp/TanMKFON16}, which can be executed within the theorem prover itself.
This is a time-consuming process: compilation within logic can be a thousand times slower (e.g., half an hour) than running the compiler outside the logic (a second or two).
But the payoff is a final theorem which only mentions the final generated machine-code implementation: all dependence on the CakeML language and implementation is discharged by proof.

\paragraph{Final Theorem}
\begin{holthmenv}
  \HOLthm[width=80]{check_countProof.check_count_compiled_thm}
\end{holthmenv}

\section{Experimental Results}
We have tested our approach against some of the past Australian
Legislative Assembly elections in ACT for years 2008 and 2012 (Figure~\ref{ref;figure2})\footnote{Tests were conducted on one core of an Intel Core i7-7500U CPU~\@ 2.70GHz$\times$4 Ubuntu~16.4 LTS}. The certificates have been produced by the Haskell program extracted from our previous formalization of ANU\_Union STV in Coq~\cite{DBLP:conf/voteid/GhaleGP17}.
\begin{figure}
\centering
%\begin{tabu} to 0.86\textwidth {X[c] X[c] X[c] X[c] X[c] X[c]}
\begin{tabular}{|l |c |c |c |c |c|c|}
\hline
electoral & ballots& vacancies& candidates& time (sec)& certificate size (MB)&year\\
\hline
%\end{tabular}
%\begin{tabu} to 0.86\textwidth {X[l] | X[c]  | X[c] | X[c] | X[c] | X[c]}
%\begin{tabular}{c c c c c c}
Brindabella &$63334$&$5$&$19$&$86$&$54.4$&2008\\
Ginninderra &$60049$&$5$&$27$&$118$&83.0&2008\\
Molonglo &$88266$&$7$&$40$&$329$&211.2&2008\\
Brindabella&$63562$&$5$&$20$&$75$&74.5&2012\\
Ginninderra&$66076$&$5$&$28$&$191$&90.1&2012\\
Molonglo&$91534$&$7$&$27$&$286$&158.7&2012\\
\hline
\end{tabular}
\caption{ACT Legislative Assembly 2008 and 2012}
\label{ref;figure2}
\end{figure}

Moreover, we have studied behaviour of our executable by examining it on certificates output on randomly generated ballots. There are two interesting parameters to study, namely varying the number of ballots and varying the length of each ballot. Figure~\ref{ref;figure3} depicts results on certificates where the number of candidates is fixed at 20, vacancies are 5, and the length of each ballot is 12. It appears that the complexity of the program in the number of ballots is quadratic. Also we keep the number of ballots, vacancies, and length of each ballot fixed at 100000, 1, and 10 respectively, in order to inspect the effect of increase in the length of each ballot (Figure~\ref{ref;figure4}). The complexity of the program seems to be linear with respect to this index.
\begin{figure}
\centering
\begin{minipage}{.45\textwidth}
  \centering
\begin{tabular}{|l |c |c| c|}
\hline
ballots &certificate size& time (sec)\\
\hline
$400000$&$523.6$&$4224$\\
$200000$&$253.3$&$938$\\
$100000$&$131.1$&$461$\\
\hline
\end{tabular}
\caption{Varying number of ballots}
\label{ref;figure3}
\end{minipage}
\begin{minipage}{.5\textwidth}
  \centering
\begin{tabular}{|l |c | c|}
\hline
ballot length& certificate size& time (sec)\\
\hline
$6$&$60.2$&$140$\\
$12$&$124.0$&$298$\\
$18$&$180.5$&$325$\\
\hline
\end{tabular}
\caption{Varying length of each ballot}
\label{ref;figure4}
\end{minipage}
\end{figure}
We have implemented the protocol in an unverified certifying Haskell program as well to check the program for correctness. Figure~\ref{ref;figure5} illustrates the result of execution of this program on the ACT legislative Assembly elections for the same years as above. In two of them, even though the final winners are announced correctly, one of the steps taken from line 6 to line 5 in the certificate is invalid. Therefore, the checker rejects the whole output as invalid.
\begin{figure}
\centering
%\begin{tabu} to 0.86\textwidth {X[c] X[c] X[c] X[c] X[c] X[c]}
\begin{tabular}{|l |c |c |c |c |c|}
\hline
electoral & ballots& vacancies& candidates& checker output&year\\
\hline
%\end{tabular}
%\begin{tabu} to 0.86\textwidth {X[l] | X[c]  | X[c] | X[c] | X[c] | X[c]}
%\begin{tabular}{c c c c c c}
Brindabella &$63334$&$5$&$19$&invalid line 6&2008\\
Ginninderra &$60049$&$5$&$27$&invalid line 6&2008\\
Molonglo &$88266$&$7$&$40$&certificate OK&2008\\
Brindabella&$63562$&$5$&$20$&certificate OK&2012\\
Ginninderra&$66076$&$5$&$28$&certificate OK&2012\\
Molonglo&$91534$&$7$&$27$&certificate OK&2012\\
\hline
\end{tabular}
\caption{Unverified Haskell program with ACT elections}
\label{ref;figure5}
\end{figure}

\texttt{DP: elaborate on the error in the unverified program.}

\section{Related Work}
 There is some work combining methods of theorem proving with certification for verification intentions. However they are not carried out for vote counting. On the other hand, in context of vote counting, merely few certifying algorithms exist which are not accompanied by any verified checker.



In vote counting, there are few work which provide a certificate with their output~\cite{DBLP:conf/ausai/PattinsonS15,DBLP:conf/itp/PattinsonT17,DBLP:conf/voteid/GhaleGP17}. They mainly formalise a voting protocol inside the theorem prover Coq and then prove some desired properties about the formalised specification. Then, they extract programs into Haskell or OCaml languages to perform computations. Since the semantic of the target and source of the extraction method differ, and there is no proof that the translation occurs in a semantic-preserving way, verification of the specification does not legitimately extend to the extracted program. Moreover, these work are either not accompanied by a checker\cite{DBLP:conf/voteid/GhaleGP17}, or their checker is an unverified Haskell/OCaml program\cite{DBLP:conf/itp/PattinsonT17}. One therefore has to trust the extraction means and correct computations carried out by GHC or OCaml compiler.



On the other hand, there are frameworks combining certification and verifications tools for verifying algorithms. Alkassar et al~\cite{DBLP:journals/jar/AlkassarBMR14} combine certified computation and theorem proving with methods of code verification to establish a framework for validation of certifying algorithms. First they implement algorithms in C language. Then by using the VCC tool~\cite{DBLP:conf/icse/DahlweidMSTS09}, they obtain some pre- and postconditions, which are next generalized syntactically and then implemented in the Isabella theorem prover to be discharged. Even though this method introduces a uniform platform for dealing with certifying algorithms, the user has to trust the VCC tool, and there is duplication of effort in that one has to generalise the conditions imposed by the VCC and then implement them manually in Isabella to prove. To ameliorate this disadvantage, Noschinski et al~\cite{DBLP:conf/nfm/NoschinskiRM14} replaced the intermediate step where VCC is invoked by the AutoCorres~\cite{DBLP:conf/itp/GreenawayAK12} verifier which provably correctly translates (part of) C language into Isabella in a semantic preserving manner. Although the latter method is much superior in the degree of the verification achieved, one can not guarantee that the machine code behaves in the same way as its top-level C implementation.

\section{Discussion and Conclusion}
Members of the general public outsource the task of vote counting of an election
in a democratic system to authorities in order to safeguard their
preferences.Therefore correct, publicly verifiable, transparent
election count is a key constituent of establishing trustworthiness
in the final outcome. We have combined
tools of theorem proving with certification techniques to accomplish this task in
a cost-effective way. The tool developed here has clarity in encoding, precision
in formulation, and modularity in implementation so that it can be taken as a
framework for verifying STV election results down to machine level.



The framework introduced is implemented in the HOL theorem prover and CakeML verified compiler. Separation of program from proofs offered in HOL environment makes our formalisation clear so that external scrutineers may simply examine the specification of the frame work to understand what it does, rather than necessarily bothering with proofs and computational components. Also rich rewriting tactics and libraries of HOL allows us to express the protocol and discharge related proofs with a minimum amount of lines of encoding. Moreover, the verified connection of HOL with CakeML enables verification performed inside the theorem prover to be pushed down to machine level. Furthermore, besides concision and clarity, the framework is efficient. As the experimental results witnesses, certificates of the Molonglo district, the biggest Legislative Assembly electorate in Australia, are checked in merely five minutes.



Our framework is modular in two different ways.
On the one hand,
the formalisation realises the counting scheme as a set of standalone logical
rules. On the other hand, each of the rules comprises independent
assertions.
Since every STV election consists of
counting, elimination, transfer, electing and declaration of
winners, we only need to change some of these rules locally to
capture different variants.
For example, the STV version used in the Senate
elections of Australia requires transfer of excessive votes of an
elected candidate before any other rule can apply. This difference
can be formalised in our system simply by modifying a single
component of the \textsf{TRANSFER} rule. So for establishing
verification results, we simply have to discharge a few
correspondences in HOL. Furthermore, the steps of translation into
CakeML and executable extraction process mainly remain unaffected.

\bibliographystyle{splncs03}
\bibliography{paper,delta2,ev}
\end{document}
% vim: ft=tex
