\documentclass{llncs}
\usepackage{etoolbox}
\usepackage{wrapfig}
\usepackage{graphicx}
\usepackage{bussproofs}
\usepackage{holtexbasic,url,amsmath,environ}
\renewcommand{\HOLTokenTurnstile}{\ensuremath{\vdash\!\!}}
\renewcommand{\HOLinline}[1]{\ensuremath{#1}}
\renewcommand{\HOLKeyword}[1]{\mathsf{#1}}
\renewcommand{\HOLConst}[1]{{\textsf{\upshape #1}}}
\renewcommand{\HOLTyOp}[1]{\textsf{\itshape #1}}
\renewcommand{\HOLSymConst}[1]{\HOLConst{#1}}
\renewcommand{\HOLTokenBar}{\ensuremath{\mathtt{|}}}

\ifdef{\dpspecial}{
%% tmp by Dirk
\newcommand{\HOLtm}[1]{\texttt{#1}}
\newcommand{\HOLty}[1]{\texttt{#1}}
\newcommand{\HOLthm}[2][]{\texttt{#2}}
\newcommand{\n}{\\n}
}{}
\NewEnviron{holthmenv}{\[\begin{array}[t]{l}\BODY\end{array}\]}
\newcommand{\TODO}[1]{{\bf TODO:} #1}
\begin{document}
\title{Verified Certificate Checking for Counting Votes}
\author{
Milad~K.~Ghale\inst{1}\and
Dirk~Pattinson\inst{1}\and
Ramana~Kumar\inst{2}\and
Michael Norrish\inst{3}}
\institute{Australian National University\and
Data61, CSIRO and UNSW\and
Data61, CSIRO, ANU}
\maketitle
\begin{abstract}
We introduce a new framework for verifying electronic vote counting
results that are based on the Single Transferable Vote scheme (STV).
Our approach frames electronic vote counting as certified
computation where each execution of the counting algorithm is
accompanied by a certificate that witnesses the correctness of the
output. These certificates are then checked for correctness
independently of how they are produced. 
We advocate to verify the verifier rather than the software used to
produce the result. We use the theorem prover HOL to formalise the
STV vote counting scheme, and obtain a fully verified
certificate checker.
By connecting 
HOL with the verified CakeML compiler, we then extract an
executable that is 
guaranteed to behave
correctly with respect to the formal specification of the
protocol down to machine level.
We demonstrate that our verifier can check certificates of real-size elections
efficiently. Our encoding is modular, so repeating the same process
for another different STV scheme would require a minimal amount of
additional work.  \end{abstract}

\section{Introduction}\label{sec:intro}

The main contribution of this paper is a new framework for
verifiably correct vote counting.
%
Electronic voting is becoming more and more prevalent worldwide.
But almost scandalously,
the current state of affairs leaves much
to be
desired, given that the public vote is a cornerstone of
modern democracy.
Indeed electronic techniques as they are used now may be seen as a step back from traditional
paper based elections.

For example, the vote counting software that is used in Australia's
most populous
state, the state of New South Wales,
was found to contain errors that had an impact in at least one seat that
was wrongly filled with high probability.
This was not only reported in specialist publications
\cite{Conway:2017:ANS} but
also in the national press \cite{Brooks:2017:NCE}.

When counting ballots by hand,  the counting is monitored by
scrutineers, usually members of the general public or stakeholders
such as party representatives and members of the general public.
%
In contrast,  computer software that is used to count ballots
merely produces a final result. Moreover, in many cases, the source
code of these programs is commercial in confidence, and there is no
evidence of the correctness of the count that could be seen as
analogous to scrutineers in traditional, paper-based vote counting.

It is universally recognised that transparent and verifiable vote
counting is a key constituent to
establish trustworthiness, and subsequently trust, in the final outcome.
The computer-based methods
currently in use fail to meet both expectations.

In the literature on electronic voting, the notion of \emph{universal
verifiability} of vote counting (any voter can check that the
announced result is correct on the basis of the published ballots
\cite{Kremer:2010:EVE}) has long been recognised as being
central,
both for guaranteeing  correctness, and building trust,
in electronic elections. This notion has three subproperties; verifiability of casting votes as intended by voters, recording votes as intended, and counting votes as recorded~\cite{DBLP:journals/iacr/CortierGKMT16}. The aim of this paper is only to address the last property, namely \emph{verifiability of the tallying process}. 
 

The approach presented here combines the concept of certifying
algorithms \cite{DBLP:journals/csr/McConnellMNS11} with formal specification and
theorem proving to address this challenge. In a nutshell, a
\emph{certifying algorithm} is an algorithm that produces, with
every execution, an easily-verifiable certificate of the correctness
of the computed result.  This certificate can then be scrutinised by
a verifier, independently of the tools, hardware or software that
were used to create the certificate.

Our focus in this paper is on the \emph{verifier}. We briefly
discuss a
concise formal specification of \emph{single transferable vote} (STV), a
complex, preferential voting system used e.g. in Ireland, Malta, New
Zealand and Australia for multi-seat constituencies. From this specification, we develop a notion
of \emph{certificate} so that correct certificates guarantee
correctness of election results. The main body of our work concerns
the \emph{verifier} (certificate checker), and we present a
synthesis of the verifier that is itself fully verified down to the
machine-code level.


This proceeds in four steps\footnote{Source codes of the formalisation can be found at\\ {\tt\url{https://github.com/MiladKetabGhale/Checker}.}}
.
First, we formalise  the vote counting protocol as a sequence of
steps inside the HOL theorem prover where every step
corresponds to an action taken by a counting officer in a
paper-based setting.  There are two kinds of stages that we call
\emph{judgements} in analogy to typing assertions in type theory.
\HOLtm{Final} judgements just declare the set of winners.
\HOLtm{NonFinal} judgements represent the current state of the count
as a tuple, corresponding to a snapshot of the stage
of the count in a paper-based setting.  The formalisation of the
voting protocol then takes the form of \emph{rules} that specify how
to advance from one judgement to the next, thereby progressing the
count. The applicability of particular rules are described
by side conditions that are in turn formalised by HOL predicates.  A
correct certificate is then simply a sequence of judgements where
each judgement is justified through its predecessor by means of a
correct rule application.  The task of the verifier is then simply
to process a list of judgements and ascertain that this is indeed
the case.  In particular, our specification of rules is purely
descriptive.


Second, in tandem with the logical specification of each rule, we
define a Boolean-valued function that checks whether or not the rule has
been applied correctly.  This then directly gives rise to the
verifier that, at every step, just checks whether any of the rules
is applicable, using the corresponding Boolean-valued function.

Third, we establish correspondence between the logical
definitions and their computational counterparts. This boils
down to formally establishing that the logical specification holds
if and only if the Boolean-valued function returns true, which in
turn implies the correctness of the certificate verifier.
This allows us to conclude that a valid certificate indeed
implies that the election protocol has been carried out in
accordance to the specification.


In the fourth, and last step, we synthesise an implementation of  the verifier and produce a proof of this implementation's correctness.  This is
achieved by using proof-producing synthesis~\cite{JFP14} of CakeML code from the HOL definitions, then using the verified CakeML compiler~\cite{DBLP:conf/icfp/TanMKFON16} to produce the machine code.
To perform computation on an actual certificate, we define the formal
syntax for certificates, and a parser in HOL, that we combine with the
I/O mechanisms of CakeML to obtain the verifier.
The result is an executable verifier that provably validates a
certificate if and only if the certificate witnesses a correct
execution of the vote counting protocol.

In summary, our slogan is ``verify the verifier''. Rather than
verifying the \emph{program} that performs an election count, we
demand that a program produces a certificate that we can then
independently verify. This has several advantages. For one, it is
much less labour intensive to verify the verifier, compared with
verifying the counting program. Second, having verifiable certificates at hand
meets the goal of universal verifiability~\cite{DBLP:conf/esorics/KremerRS10}.
Third, we achieve correctness over a minimal trust base through the
use of CakeML.

In the remainder of the paper, we describe our framework in detail
and demonstrate that it can handle real-world size elections by
evaluating it on historical data of elections conducted in
Australia. 
\section{The Protocol and its HOL Formalisation}

Single Transferable Vote is a preferential voting scheme that is
used in multi-seat constituencies. Voters rank (possibly
a subset of) candidates by assigning numerical preferences to
candidates 
%as in the ballot on the right, 
where no two candidates may be given the 
same preference. This allows us to represent ballots as duplicate
free lists of candidates where the list order reflects the
preference order.
%\begin{wrapfigure}{r}[0cm]{0.4\textwidth}
%  \begin{center}
    %%\raisebox{0pt}[-1cm]
%    \raisebox{0pt}[\dimexpr\height-3.0\baselineskip\relax]
%    {\includegraphics[width=0.37\textwidth]{ballot.png}}
%    \vspace*{-12ex}
    %%\raisebox{0pt}[\dimexpr\height-8.5\baselineskip\relax]{xx}
    %%\includegraphics[width=4cm]{ballot.png}
%  \end{center}
%\end{wrapfigure}


Each election defines a \emph{quota}, i.e. a minimal set of votes
that a candidate must receive in order to be elected. The count
starts by counting all voters' \emph{first preferences}, and
candidates who reach the quota are elected, but more often than not,
there will still be seats to fill.  This is effected by two
mechanisms:
\begin{enumerate}
  \item Transfer of surplus votes. Votes for elected candidates in
excess of the quota are distributed to (and counted in favour of)
the next preference listed on the ballot.
  \item Elimination of candidates. The candidate with the
\emph{least} number of first preferences is eliminated from the
election, and their votes are then distributed to the next listed
preference on the ballot.
\end{enumerate}

\noindent
We give a precise definition of STV below. The main idea of
distributing surplus votes is to account for \emph{additional}
candidates favoured by a voter if their first preference is already
elected, whereas elimination honours voters'
follow-on preferences if their first preference \emph{cannot} be
elected.  Of course, the key question is precisely which ballots
should be considered surplus and distributed to the next preferences, as follow-on preferences will
generally differ. This is the purpose of a third mechanism:

\begin{enumerate}
\setcounter{enumi}{2}
\item Fractional Transfer. \emph{All} suprlus votes are transfered
to the next preference, but at a \emph{reduced} weight that is
proportional to the size of the surplus.
\end{enumerate}

\noindent
For example, if a candidate exceeds the quota by 20\%, all first
preference votes for that candidate are re-assigned a weight of
$0.2$ and re-injected into the count, and regarded as
first-preference votes for the subsequently listed candidate. In
other words, the number of first preference votes for a candidate is
the sum of the \emph{weights} of ballots where that candidate is
listed as first preference. The initial weight of all ballots is
$1$.

There are various versions of STV. They mainly differ in how  and
when ballots are transferred and candidates are elected, the
calculation of the transfer value, and the various tie breaking
methods used to determine which candidate is to be excluded, and the
quota being used. 
Here, we deal with a generic version of STV that
incorporates all three mechanisms outlined above, and is very
similar to the method used to elect members of the Australian
Senate, and incidentally also to the scheme used elect the representatives of the
student's union of the first and second author. Throughout, we do
not assume a particular definition of the quota, but take this as a
parameter. Design decisions in
the precise formulation of the scheme are resolved as follows:

\begin{description}
\item[Step-by-step surplus transfer.] Surplus votes of
elected candidates that have exceeded the quota  are transferred
in order of number of first preferences received.  That is, surplus
votes of the candidate with the largest number of first preferences
are transferred first.
\item[Electing after each transfer.] After each
transfer of surpluses, candidates that reach the quota after
surplus votes are being elected immediately.
\end{description}


\noindent
The description of the formal protocol that we are analysing uses
the following terminology. A \emph{continuing candidate} is a
candidate that has neither been elected nor eliminated.
The \emph{first preference} of a
ballot is the most preferred continuing candidate, and the
\emph{transfer value} of a ballot is the fractional weight of a
ballot. We keep track of the following data throughout:
\begin{itemize}
  \item the set of \emph{uncounted ballots}
  \item a \emph{tally} for each candidate, the sum of the transfer
values of all ballots counted in the candidate's favour
  \item a \emph{pile} for each candidate that contains all ballots
counted in favour of the respective candidate
  \item an  queue of candidates that await surplus transfer
\end{itemize}
Initially, the queue for surplus transfer, as well as the piles
associated to the individual candidates are empty, all ballots are
uncounted, and all
candidates are continuing.
From this initial state, the protocol proceeds as follows:
\begin{center} \begin{enumerate}
\item determine the set of \emph{formal} ballots, i.e. those ballots
that represent a total order of preferences over a subset of
candidates, each of which receives an initial transfer value of $1$.
\item determine the number of first preference votes (the tally) for each
continuing candidate. In doing this, record which vote is counted for which
candidate by adding the ballot paper to the respective pile.
\item if there are unfilled seats, all
candidates that have reached the quota are elected, and are added to
the transfer
queue  in order of their tally
\item if all the vacancies have been filled, counting terminates and the result
is announced.
\item if the number of unfilled vacancies equals or exceeds the number
of continuing candidates, all continuing candidates are elected and the
result is announced.
\item if there are still vacancies, all ballots are counted, and the
transfer queue is not empty, remove the first candidate from the
transfer queue and transfer their votes (the votes on their pile)
to the next preference by declaring these votes to be uncounted and
the transfer value given by

\begin{equation}  \label{eq:tv} \mbox{new value} =
\frac{\mbox{number of votes of elected candidate} -
\mbox{quota}}{\mbox{number of votes of elected candidate}}
\end{equation}

\noindent Subsequent transfer values are computed as the product of
the current value with previous transfer value.
\item if there are
still vacancies, all ballots are counted, and all surplus votes
are transferred, choose the candidate with the least amount of first
preference votes and exclude that candidate from the set of
continuing candidates. All votes counted in favour of the eliminated
candidate are transferred to the next preference (with unchanged
transfer value).
\end{enumerate} \end{center}

\noindent
The purpose of setting aside the ballots counted for particular
candidates in the second step is precisely for the purpose of
possibly transferring these ballots later, in case the candidate is
either elected or eliminated.

\subsection{An Example Certificate}

As argued in the introduction, in the framework of certified
computation, each step of the protocol is evidenced. Each of the
steps outlined above is formalised as a rule that progresses the
count. Rules have side conditions (e.g. candidates having reached
the quota, or all ballots being counted) and rule application
changes the data that we track throughout the count (e.g. updating
the tally, or removing a candidate from the set of continuing
candidates). We given an example certificate in
Figure~\ref{fig;figure}.
Here, we have a
small election
with three candidates $A$, $B$ and $C$, and an initial set of
ballots containing
$b_1=([A,C],1)$, $b_2=([A,B,C],1)$, $b_3=([A,C,B],1)$,
$b_4=([B,A],1)$, $b_5=([C,B,A],1)$.  Each ballot is a pair, where
the first component is a preference-ordered list of candidates, and
the second is the transfer value (initially set to $1$). The
certificate consists of a \emph{header} that specifies the quota as
a fraction, the number of seats to be filled, and the list of
candidates being voted on.
The fourth line is the election result, and the remainder of the
certificate consists of the intermediate steps that lead to this
outcome.
%\vspace*{-0.1cm}
\begin{small} \begin{figure}[b]
\begin{tabular}{c@{\hspace{2cm}}c} 
\AxiomC{\tiny 8/3} \noLine

\UnaryInfC{\tiny 2} \noLine \UnaryInfC{\tiny $[A,B,C]$} \noLine

\UnaryInfC{\scriptsize [A,C]} \RightLabel{\tiny hwin}

\UnaryInfC{\tiny [$b_4$,([A,B,C],1/9)]]; A[3/1] B[10/9] C[11/9]; A[] B[]
C[$b_{5}$,([C],1/9),([C,B],1/9),([C],11/100)]; []; [A]; [C]}

\RightLabel{\tiny elim} \UnaryInfC{\tiny []; A[3/1] B[10/9]
C[11/9], A[] B[$b_4$,([A,B,C],1/9)]
C[$b_5$,([A,C],1/9),([A,C,B],1/9)]; []; [A]; [B,C]}

\RightLabel{\tiny count} \UnaryInfC{\tiny
[([A,C],1/9),([A,B,C],1/9),([A,C,B],1/9)]; A[3/1]
B[1/1] C[1/1]; A[] B[$b_4$] C[$b_5$]; []; [A]; [B,C]}

\RightLabel{\tiny transfer} \UnaryInfC{\tiny []; A[3/1] B[1/1]
C[1/1]; A[([A,C],1/9),([A,B,C],1/9),([A,C,B],1/9)]
B[$b_4$] C[$b_5$]; [A]; [A]; [B,C]} \RightLabel{\tiny elect}

\UnaryInfC{\tiny []; A[3/1] B[1/1] C[1/1]; A[$b_1$,$b_2$,$b_3$]
B[$b_4$] C[$b_5$]; []; []; [A,B,C]} \RightLabel{\tiny count}

\UnaryInfC{\tiny ba; A[0/1] B[0/1] C[0/1]; A[] B[] C[]; []; [];
[A,B,C]} \DisplayProof \end{tabular} \caption{Example
Certificate} \label{fig;figure} \end{figure} \end{small}

The certificate records every step of the count, where a step
corresponds to a rule application, where the rules themselves are
modelled on valid actions that of counting officers to progress the
count. The inspection of a certificate therefore corresponds to
witnessing all the individual steps that take place in a
hypothetical counting station.

Intermediate stages of the count record six pieces of information,
separated by semicolons:  the ballots the are still to be counted,
the tallies of all candidates, the ballots counted in favour of each
candidate, the transfer queue, and finally the sets of continuing
and elected candidates. We briefly illustrate the protocol using the
certificate in Figure \ref{fig;figure} as an example, going though
the protocol step-by-step.
%\begin{itemize}

\noindent\textbf{count.} First preferences for each candidates are computed,
and ballots counted in favour of particular candidates are placed
onto that candidate's pile. Here, $A$ is the first preference on
$b_1$, $b_2$, and $b_3$ (leading to a tally of 3), and $B$ receives $b_4$, and
C receives $b_5$. Tallies are updated so that tally of A becomes
$3$, and B and C each reach $1$.\\
\noindent\textbf{elect.} Candidate A exceeds the quota, and is elected. The
transfer value of all ballots counted in $A$'s favour  changes to
$1/9$ according to formula (\ref{eq:tv}). The updated pile of A
reflects this change in transfer values, and now contains
$([A,C],1/9)$, $([A,B,C],1/9)$, and $([A,C,B],1/9)$. The data
associated with $B$ and $C$ doesn't change.\\
\noindent\textbf{transfer.} As there are vacancies and no one else has reached
or exceeded the quota, the surplus of A is dealt with. The list of
uncounted ballots is updated to contain the votes for $A$ (with
transfer values updated in the previous step).\\
\noindent\textbf{count.} As there are uncounted ballots (again), tallies are
updated. As $A$ is no longer a continuing candidate, the votes are
counted in favour of the highest-ranked continuing candidate.
That is, C receives  two new votes (each of value $1/9$) which
are $([A,C],1/9)$ and $([A,C,B],1/9)$. Candidate B receives one vote,
which is $([A,B,C],1/9)$.\\
\noindent\textbf{elim.} No continuing candidate has reached the quota, one
vacancy is still unfilled, and all ballots are (again) counted.
Hence the candidate with the lowest tally is eliminated (in this
case, $B$) and their votes (with unchanged transfer values) are
again injected into the count.\\
\noindent\textbf{hwin.} The only continuing candidate, that is C, is elected and as we have filled all the vacancies, a final stage has been obtained.
%\end{itemize}

\noindent
To validate certificates of this form, we first parse the textual
representation into actual data structures, and then check the
certificates for correctness on the basis of a HOL formalisation
that we now describe.

\subsection{The HOL Formalisation}
\setlength{\abovedisplayskip}{0.5em}
\setlength{\belowdisplayskip}{0.5em}

Elections are \emph{parameterised} by the data in the header
(candidates, quota and number of vacancies) that remain constant
throughout the count. We use the term \emph{judgement} for the data-structure representation of
the various stages of the count.  They come in two flavours: final
judgements announce the winners, and non-final judgements are
intermediate stages of the execution of the protocol.

\begin{definition}[Judgements]
We formalise judgements as a datatype with two constructors. The
first constructor, \HOLtm{Final w} represents a final stage of the
computation, where $w$ is the final list consisting of all of the
declared elected candidates. The second constructor,
\HOLtm{NonFinal (ba,t,p,bl,e,h)} is an intermediate stage of the
computation, where $\mathit{ba}$ is the list of uncounted ballots at this
point, $t$ is the tally list recording the number of votes of each
candidate has received up to this point, $p$ is the pile list of
votes assigned to each candidate, $\mathit{bl}$ is the list of elected whose
surplus have not yet been transferred, $e$ is the list of elected
candidates by this point, and $h$ is the list of continuing
(hopeful) candidates up to this stage.
\begin{holthmenv}
\HOLthm[width=80]{CheckerSpec.datatype_judgement}
\end{holthmenv}
\end{definition}

\noindent
%Definition~\ref{jud:hol} below gives our straight forward HOLencoding of judgements.
We use lists (instead of sets, or multisets)
mainly for convenience of formalisation in HOL, but this is not used
in an essential way either in the definition, or in the
formalisation, of the counting rules that we give later.
By choosing to
formalise the tally and pile as lists rather than functions
operating on the list of candidates, judgements become an instance
of the equality type class which we use later on in specification
and reasoning about counting rules. Additionally, this formulation
reduces the gap between an actual certificate and its abstract
syntactic representation which we refer to as a \emph{formal
certificate}. 


\noindent
As a (formal) certificate consists of a sequence of judgements, each of
which represents a state of the count, we need to verify the
correctness of the transitions between successive judgements.
Each rule consists of three main components:
\begin{itemize}
  \item a specification of how premiss and conclusion relate
  \item side conditions that specifies when a rule is applicable
  \item a number of implicit assertions that guarantee the integrity
of the data.
\end{itemize}

%\texttt{DP: concrete example here?}
\noindent
For example, we expect a valid certificate to have no duplication in
the list of elected or continuing candidates, and every candidate
must have only one tally and one pile at every non-final judgement.

Crucially, the specification of the counting rules is purely
\emph{descriptive}. To effectively check certificates, we augment
each (specification of a) rule with an actual decision procedure
that, given two judgements, returns either true or false, depending
on whether the rule is applicable or not. The decision procedure and
the formal specification are connected by (formal) proofs of
soundess and completeness, as shown in the figure below.

\includegraphics[scale=0.35]{spec-dec-cropped.pdf}
\noindent
Here, \emph{soundness} refers to the fact that the decision
procedure only stipulates that a rule has been correctly applied if
the application is in accordance with the specification and
\emph{completeness} says that this will happen whenever the rule is
applicable. The decision procedures are actual functions in HOL that
we then translate and extract using CakeML to guarantee
machine-level correctness, and both soundness and completeness are
established formally in HOL. We illustrate this in detail with the
elimination rule.


% \subsection{The Case of the Elimination Rule}

\paragraph{Integrity Constraints.} The integrity constraints for the
elimination rule are identical to those of other rules.
For example, the name of each candidate appears only once in the
initial list of competing candidates. 
Also, at every stage of the count, every candidate has exactly
one tally and one pile (of votes
counted in their favour). Therefore, if a judgement in a certificate
maliciously allocates more than one tally to a single candidate, the
bug is detected and the certificate rejected as invalid.  We express
this condition as follows.
\begin{small}
\begin{holthmenv}
  \HOLthm[def,width=80]{CheckerSpec.Valid_PileTally_def}
\end{holthmenv}
\end{small}
\noindent
The above predicate is paired with computational twins, and soundness
and completeness connect both.  Here,
given lists $t$ and $l$, the function \HOLtm{Valid_PileTally_dec1} decides if every first element of each pair in $t$ is a member of $l$.
\begin{small}
\begin{holthmenv}
  \HOLthm[def,width=80]{Checker.Valid_PileTally_dec1_def}
\end{holthmenv}
\end{small}
Additionally, the function \HOLtm{Valid_PileTally_dec2} determines if each element of $l$ appears as the first component of a pair in $t$.
\begin{small}
\begin{holthmenv}
  \HOLthm[def,width=80]{Checker.Valid_PileTally_dec2_def}
\end{holthmenv}
\end{small}
We prove that the formal specification \HOLtm{Valid_PileTally}  corresponds with the functions \HOLtm{Valid_PileTally_dec1} and \HOLtm{Valid_PileTally_dec2}. Therefore we ensure that tallies and piles are distinctively allocated to candidates.
\begin{small}
\begin{holthmenv}
\HOLthm[width=80]{CheckerProof.Valid_PileTally_Spec_iff_Valid_PileTally_DEC}
\end{holthmenv}
\end{small}
\noindent\emph{Side Conditions.} The item 7 of the protocol on page 5, specifies when and how a candidate shall be eliminated from the election. It stipulates that
%\vspace*{-0.4cm}
\begin{itemize}
  \item[a.]  there are empty seats 
 \item[b.] there are no votes to count at this stage and there are no pending transfer
\item[c.] determine the candidate $c$ who has the minimal amount of tally
\item[d.] eliminate the candidate $c$
 \item[e.] votes of the eliminated candidate $c$ are transferred according to the next preference with the same value.
 \end{itemize}
 %\vspace*{-0.3cm}
To illustrate how explicit clauses of the protocol are formalised, we explain the way that we have specified item (d) inside HOL. We introduce the predicate \textsf{equal\_except} which formally asserts when two lists are equal except for one exact element.
%\vspace*{-0.2cm}
\begin{small}
\begin{holthmenv}
  \HOLthm[def,width=80]{CheckerSpec.equal_except_def}
\end{holthmenv}
\end{small}
The computational twin of this definition decides whether
two list match with the exception of one element.  This is the
function \textsf{equal\_except\_dec}.
%\vspace*{-0.1cm}
\begin{small}
\begin{holthmenv}
  \HOLthm[def,width=80]{Checker.equal_except_dec_def}
\end{holthmenv}
\end{small}
%\vspace*{-0.1cm}
We formally establish that this function implements
the specification given by the \textsf{equal\_except} predicate.
%\vspace*{-0.1cm}
\begin{small}
\begin{holthmenv}
  \HOLthm[width=80]{CheckerProof.EQE_REMOVE_ONE_CAND}
\end{holthmenv}
\end{small}
%\vspace*{-0.1cm}
Moreover, modulo extensional equality, the function \textsf{equal\_except\_dec} is unique.
%\vspace*{-0.1cm}
\begin{small}
\begin{holthmenv}
  \HOLthm{CheckerProof.EQE_IMP_REMOVE_ONE_CAND}
\end{holthmenv}
\end{small}
%\vspace*{-0.1cm}
\noindent
Having defined the implicit integrity constraints, and the
explicit side conditions in the definition of \emph{elimination}, we
can present the formalisation of this rule in HOL as a predicate.


The \textsf{ELIM\_CAND} rule specifies what it means to legitimately eliminate a given candidate $c$. It is defined on three kinds of input; a
candidate, a triple composed of three fixed parameters which are the
quota, vacancies, and the initial list of candidates, and two
judgements $j_{1}$ and $j_{2}$ (the premiss and the conclusion of the rule). 
\begin{small}
\begin{holthmenv}
  \HOLthm[def,width=85]{CheckerSpec.ELIM_CAND_def}
\end{holthmenv}
\end{small}
 The first and the fourth component of $j_{1}$ which correspond to the list of uncounted ballots and the backlog are both empty. This realises the condition (a) stated above. It is also required that $h$ the list of continuing candidates in the premise $j_{1}$, and $nh$ the updated list of continuing candidates in $j_{2}$ satisfy the predicate \textsf{equal\_except} so that condition (d) is met. Each of the conjuncts in the definition of \textsf{ELIM\_CAND} encapsulates part of the item 7 in the protocol. 


 Similar to the case of \textsf{equal\_except}, for each of the conjuncts, we define a computational counterpart and prove the equivalence of the the conjunct with its computational realisation. Conjunction of these computational definitions is \textsf{ELIM\_CAND\_dec}, which is the computational equivalent of the predicate \textsf{ELIM\_CAND}.
\begin{small}
\begin{holthmenv}
  \HOLthm[def,width=88]{Checker.ELIM_CAND_dec_def}
\end{holthmenv}
\end{small}
By drawing upon the correspondence established between conjuncts of the elimination specification and computational counterpart, we prove that  \HOLthm{CheckerProof.ELIM_CAND_thm}. The same procedure is followed to achieve formal specification,  computational definitions, and their correspondence for the rest of counting rules. 

\subsection{The Certificate Verifier}

Clearly, one way to verify the result of a computation is to simply
re-compute (possibly using a verified
program)~\cite{DBLP:conf/stoc/BlumK89}. While this makes
perfect sense for a \emph{deterministic} program, voting protocols
generally employ tie-breaking techniques that lead to
non-determinism. In the case of STV, this for example applies when
two candidates are tied for exclusion where it is permissible to
eliminate \emph{either} of the candidates. From the perspective of certified computation, this is a non-issue,
as the certificate simply records which choice has been made (and
why this choice is permissible). Compared to simply re-computing,
the verification of a certificate provides another significant
advantage: in case of diverging results, we gain information
on precisely what step of the (incorrect) computation is to blame
for the wrong result. Computationally, the additional advantage is simplicity and speed:  the verification of the verifier is considerably
simpler than that of a fully-fledged implementation, and certificate
checking is also generally faster than re-computing.

The verification of certificates comprises two steps.
 First we need to validate whether the first
judgement of the certificate is a valid initial state of the count. A valid initial judgement is one
where candidate's tally is zero, their
piles are empty, and both the transfer queue and the list of elected candidates
are both empty as well.
\begin{small}
\begin{holthmenv}
  \HOLthm[width=80,def]{CheckerSpec.initial_judgement_def}
\end{holthmenv}
\end{small}
\noindent
Second, we check whether transitions from one judgement to the next is according to
one of the rules that define the count.
\begin{small}
\begin{holthmenv}
  \HOLthm[def,width=80]{CheckerSpec.Valid_Step_Spec_def}
\end{holthmenv}
\end{small}
\noindent
We can therefore check whether a transition from one judgement to
the next is correct by simply considering the disjunction of all
rules.
\begin{small}
\begin{holthmenv}
  \HOLthm[def,width=80]{CheckerSpec.Valid_intermediate_judgements_def}
\end{holthmenv}
\end{small}
\noindent
Putting the specification of a valid initial judgement with valid sequence of judgements together, we obtain the specification for a valid certificate:
\begin{small}
\begin{holthmenv}
  \HOLthm[def,width=80]{CheckerSpec.Valid_Certificate_def}
\end{holthmenv}
\end{small}
For checking a formal certificate we therefore first  verify that
certificate starts at a permissible initial stage. We then
iteratively 
check that transitions have happened correctly, and that the
terminating state is a final one where winners are declared. The above specification of a valid vertificate, corresponds to the following computational formal certificate checker.
\begin{small}
\begin{holthmenv}
  \HOLthm[def,width=80]{Checker.Check_Parsed_Certificate_def}
\end{holthmenv}
\end{small}
The correctness of this definition rests on the equivalences we have already established between the specifications and their computational counterparts, namely, \HOLthm[tt]{CheckerProof.initial_judgement_thm} and \HOLthm[tt]{CheckerProof.valid_judgements_thm}.
Consequently a formal certificate is validated if and only if it is valid according to
the HOL specification of \HOLtm{Valid_Certificate}.
\begin{small}
\begin{holthmenv}
  \HOLthm[def,width=80]{CheckerProof.Check_Parsed_Certificate_iff_Valid_Certificate}
\end{holthmenv}
\end{small}
\noindent
Since the HOL specification realises the protocol, a formal certificate is validated if and only if it meets the protocol's expectation. 
\section{Translation into CakeML and Code Extraction}

The verified certificate-checking function,
\HOLtm{Check_Parsed_Certificate}, described above, is a good
starting point for a verifier, but still has two shortcomings: it is a
function in logic rather than an executable program, and a
consequence, 
its inputs must be provided as elements of the respective data
types, whereas certificates are purely textual.
We now demonstrate how to address these shortcomings
and obtain a verified executable for
checking certificates.  Our final theorem about the verifier
executable is presented at the end of this section.


\paragraph{Parsing}
%\noindent\emph{Parsing}
The input to the verifier is a textual certificate file, in a format similar to Figure~\ref{fig;figure}.
We specify this file format indirectly, by defining an executable specification of a certificate parser.
\begin{small}
\begin{holthmenv}
  \HOLthm[def,width=90]{check_countProg.Check_Certificate_def}
\end{holthmenv}
\end{small}
Specifically, we define functions that take a string representing a line in the file and return either \HOLtm{NONE} or \HOLtm{SOME (x:unit)}, where \HOLtm{x} is the parsed information from the line. 
Given these parsing functions --- \HOLtm{parse_quota}, \HOLtm{parse_seats}, etc. --- we write the verifier as a function, above, that parses lines from the file then calls \HOLtm{Check_Parsed_Certificate} to do the verification.

\paragraph{Translation into CakeML and I/O Wrapper}
%\noindent\emph{Translation into CakeML and I/O Wrapper}
Using prior work on proof-producing synthesis~\cite{JFP14} we can automatically synthesise an implementation of the function \HOLtm{Check_Certificate} in the programming language CakeML.
The synthesis tool for CakeML produces a theorem relating the semantics of the synthesised program back to the logical function.
However, the result is a \emph{pure} function that expects the lines of a file as input.
To actually open the file and read lines from it, we write the impure wrapper \HOLtm{check_count} (making use of the CakeML Basis Library) around the pure function, and verify the wrapper using Characteristic Formulae for CakeML, as described by Gu\'eneau et al.~\cite{DBLP:conf/esop/GueneauMKN17}.
The result is a complete CakeML program whose I/O semantics is verified, witnessed by the theorem \HOLtm{check_count_compiled} below, to implement \HOLtm{Check_Certificate} on lines from standard input.


To elaborate further on the above step, the impure wrapper \HOLtm{check_count} calls two impure functions \HOLtm{parse_line} and \HOLtm{loop}. The former, calls I/O functions to read one line at a time from the concrete certificate given as lines on the standard input  and parse it. It comprises  two phases; one for the header of the certificate file consisting of the quota, seats number, and initial list of candidates, and the other is for parsing judgement lines. If the parsing fails due to malformedness of a line, the parser messages the appropriate error on the standard output with the line number included. However, if it succeeds, the parsed line is fed to the \HOLtm{loop} function to check if the transition from two consecutive parsed judgement lines is a valid step. The parsing and checking of judgement lines continues until either all steps are verified as correct, or an incorrect step is encountered. The following theorem asserts that the \HOLtm{loop} function returns the correct output \HOLtm{NONE} if and only if the initial line of judgements in the certificate file is indeed valid and all steps taken to move from one judgement line to its successor are correct. 
\begin{small}
\begin{holthmenv}
  \HOLthm[def,width=90]{check_countProg.loop_thm}
\end{holthmenv}
\end{small}
%\paragraph{Compilation in Logic}
\noindent\emph{Compilation in Logic}
Finally, we would like an executable verifier in machine code (rather than CakeML code).
To produce this, we use the verifed CakeML compiler~\cite{DBLP:conf/icfp/TanMKFON16}, which can be executed within the theorem prover itself.
This is a time-consuming process: compilation within logic can be a thousand times slower (e.g., half an hour) than running the compiler outside the logic (a second or two).
But the payoff is a final theorem which only mentions the final generated machine-code implementation: all dependence on the CakeML language and implementation is discharged by proof.

%\paragraph{Final Theorem}
\noindent\emph{Final Theorem}
The final theorem, which we explain further below, is about the generated machine code, represented by the constant \HOLtm{check_count_compiled}.
\begin{small}
\begin{holthmenv}
  \HOLthm[width=80]{check_countProof.check_count_compiled_thm}
\end{holthmenv}
\end{small}
We assume (\HOLtm{x64_installed}) that this code is loaded into memory in an x86-64 machine represented by \HOLtm{mc} and \HOLtm{ms}, and that the command line (\HOLtm{cl}) and file system (\HOLtm{fs}) are well-formed.
The conclusion of the theorem concerns the semantics (\HOLtm{machine_sem}) of executing the machine: it will terminate successfully (or fail if there is not enough memory) with a trace of I/O events (\HOLtm{io_events}) such that if we replay those events on the initial file system, we obtain a resulting file system \HOLtm{fs'} for which the string \HOLtm{"Certificate OK\n"} is printed on standard output if and only if \HOLtm{Check_Certificate} succeeds on the lines of standard input.
\section{Experimental Results}
We have tested our approach against some of the past Australian
Legislative Assembly elections in the Australian Capital Territory for years 2008 and 2012 (Figure~\ref{ref;figure2})\footnote{Tests were conducted on one core of an Intel Core i7-7500U CPU~\@ 2.70GHz$\times$4 Ubuntu~16.4 LTS}. The certificates have been produced by the Haskell program extracted from our previous formalisation of the same protocol in Coq~\cite{DBLP:conf/voteid/GhaleGP17}.
\vspace*{-0.3cm}
\begin{small}
\begin{figure}
\centering
%\begin{tabu} to 0.86\textwidth {X[c] X[c] X[c] X[c] X[c] X[c]}
\begin{tabular}{|l |c |c |c |c |c|c|}
\hline
electoral & ballots& vacancies& candidates& time (sec)& certificate size (MB)&year\\
\hline
%\end{tabular}
%\begin{tabu} to 0.86\textwidth {X[l] | X[c]  | X[c] | X[c] | X[c] | X[c]}
%\begin{tabular}{c c c c c c}
Brindabella &$63334$&$5$&$19$&$86$&$54.4$&2008\\
Ginninderra &$60049$&$5$&$27$&$118$&83.0&2008\\
Molonglo &$88266$&$7$&$40$&$329$&211.2&2008\\
Brindabella&$63562$&$5$&$20$&$75$&74.5&2012\\
Ginninderra&$66076$&$5$&$28$&$191$&90.1&2012\\
Molonglo&$91534$&$7$&$27$&$286$&158.7&2012\\
\hline
\end{tabular}
\caption{ACT Legislative Assembly 2008 and 2012}
\label{ref;figure2}
\end{figure}
\end{small}
\vspace*{-0.5cm}
\noindent
We also evaluated the verifier on certificates obtained through
randomly generated ballots. We vary two parameters: the number of
ballots and the size of each ballot. Figure~\ref{ref;figure3} shows
the results on certificates where the number of candidates is fixed
at 20, vacancies are 5, and the length of each ballot is 12. Also
we keep the number of ballots, vacancies, and length of each ballot
fixed at 100000, 1, and 10 respectively, in order to see the
effect of increase in the length of each ballot
(Figure~\ref{ref;figure4}). 
\vspace*{-0.2cm}
\begin{small}
\begin{figure}
\centering
\begin{minipage}{.45\textwidth}
  \centering
\begin{tabular}{|l |c |c| c|}
\hline
ballots &certificate size& time (sec)\\
\hline
$400000$&$523.6$&$4224$\\
$200000$&$253.3$&$938$\\
$100000$&$131.1$&$461$\\
\hline
\end{tabular}
\caption{Varying number of ballots}
\label{ref;figure3}
\end{minipage}
\begin{minipage}{.5\textwidth}
  \centering
\begin{tabular}{|l |c | c|}
\hline
ballot length& certificate size& time (sec)\\
\hline
$6$&$60.2$&$140$\\
$12$&$124.0$&$298$\\
$18$&$180.5$&$325$\\
\hline
\end{tabular}
\caption{Varying length of each ballot}
\label{ref;figure4}
\end{minipage}
\end{figure}
\end{small}
\vspace*{-0.5cm}
\noindent
We have also implemented the protocol in an unverified certifying
Haskell program. The unverified program was then tested on
ballots of the same ACT Legislative Assembly elections.
We have then verified the certificates produced by this program for
each of the districts. The result shows that the certificates of the
districts for the year 2012 are valid. Also the certificate of
Molonglo electorate 2008 is verified as correct. However, the two
electorates of Brindabella and Ginninderra 2008, despite declaring
the final winners correctly, were \emph{invalid} as an error occurs in an
intermediate transition on line 6 in both certificates. 
%In both cases the ckecker invalidates the
%transition from  line 5 to line 6.


%Figure~\ref{ref;figure5} illustrates the result of execution of this program on the ACT legislative Assembly elections for the same years as above. In two of them, even though the final winners are announced correctly, one of the steps taken from line 6 to line 5 in the certificate is invalid. Therefore, the checker rejects the whole output as invalid.
%\begin{figure}
%\centering
%\begin{tabu} to 0.86\textwidth {X[c] X[c] X[c] X[c] X[c] X[c]}
%\begin{tabular}{|l |c |c |c |c |c|}
%\hline
%electoral & ballots& vacancies& candidates& checker output&year\\
%\hline
%\end{tabular}
%\begin{tabu} to 0.86\textwidth {X[l] | X[c]  | X[c] | X[c] | X[c] | X[c]}
%\begin{tabular}{c c c c c c}
%Brindabella &$63334$&$5$&$19$&invalid line 6&2008\\
%Ginninderra &$60049$&$5$&$27$&invalid line 6&2008\\
%Molonglo &$88266$&$7$&$40$&certificate OK&2008\\
%Brindabella&$63562$&$5$&$20$&certificate OK&2012\\
%Ginninderra&$66076$&$5$&$28$&certificate OK&2012\\
%Molonglo&$91534$&$7$&$27$&certificate OK&2012\\
%\hline
%\end{tabular}
%\caption{Unverified Haskell program with ACT elections}
%\label{ref;figure5}
%\end{figure}
Based on the aforementioned error message, we only need to
inspect a very small part of the certificate. Upon closer
inspection, we have uncovered a subtle error in the implementation
of the elimination rule. 
On the other hand, the same program successfully (and correctly) computes election
results of other districts which substantiates the subtlety of the
error.
We argue that precisely because of such delicacies in the STV
protocol and hence their implementation, we advocate that vote
counting be carried out in a certified way, with a minimal trust
base such as demonstrated in this paper.


\section{Discussion}
Universal verifiability is a security requirement introduced for measuring verifiability of  an election result by any member of the public~\cite{DBLP:journals/iacr/CortierGKMT16}.  The literature on election protocol design agrees on the textual formulation of the concept, despite the fact that they vary in the technical implementation of the property~\cite{DBLP:journals/iacr/CortierGKMT16}. Moreover, it is accepted that satisfaction of the property rests on verifying three subproperties, namely cast-as-intended, recorded-as-intended, and count-as-recorded~\cite{DBLP:journals/iacr/CortierGKMT16}, and  also demonstration of the eligibility verifiability~as an explicitly or implicitly stated prerequisite~\cite{DBLP:conf/sp/KustersTV11}. 


Our framework only aims at addressing verification of the count-as-recorded subproperty. We do not attempt to introduce an election protocol for answering expectations of the  universal verifiability. Therefore, verification of other two subproperties and the eligibility criterion falls outside the focus of the current work. However, our tool can be perfectly employed by any election protocol which accommodates STV scheme and uses Mix Net~\cite{DBLP:journals/ieeesp/Chaum04} for anonymising and decrypting ballots. For example, some protocols require the authorities to produce a witness for tallying and then verify it is a proof of correctness for the announced tallying result~\cite{DBLP:conf/post/CortierEKMW15}. Such systems can adapt certification and the checker for (a) offering an independently checkable witness of tallying, and (b) provably correctly verify the certificate.     

    
The framework employs CakeML to achieve an end-to-end verification of certificates. Therefore we prove that executable checker is verified to behave according to its specification in  HOL, which operates in a different environment. To obtain this level of verification, we rely on the verified proof-synthesis tool of CakeML, the mechanism for producing deeply embedded equivalent assertions of HOL functions into CakeML environment, the Characteristic Formula of CakeML to assert that the pure (deeply embedded functions) behave consistently with the impure I/O calls, and the verified compiler that generates executable that provably respects all of the above proofs.
 

 
Furthermore, separation of program from proofs
offered in HOL environment makes our formalisation clear so that
external scrutineers may simply examine the specification of the
framework to understand what it does, rather than necessarily
bothering with proofs and computational components. Also rich
rewriting tactics and libraries of HOL allow us to express the
protocol and discharge related proofs with a minimum amount of lines
of encoding.  We have demonstrated the practical
feasibility of our approach by means of case studies. For example,
the certificates of the Molonglo
district, the biggest Legislative Assembly electorate in Australia,
are checked in just five minutes.




Our framework is modular in two different ways.
On the one hand,
the formalisation realises the counting scheme as a set of standalone logical
rules. On the other hand, each of the rules comprises independent
assertions.
Since every STV election consists of
counting, elimination, transfer, electing and declaration of
winners, we only need to change some of these rules locally to
capture different variants.
For example, the STV version used in the Senate
elections of Australia requires transfer of excessive votes of an
elected candidate before any other rule can apply. This difference
can be formalised in our system simply by modifying a single
component of the \textsf{TRANSFER} rule. So for establishing
verification results, we simply have to discharge a few
correspondences in HOL. Furthermore, the steps of translation into
CakeML and executable extraction process mainly remain unaffected.


\section{Related Work}
To satisfy universal verifiability, a protocol has to meet expectations of three subproperties cast-as-intended, recorded-as-intended, and counted-as-recorded. Since only the last property concerns us, we  simply overview a few existing work from the perspective of their tally verification methods. Moreover, there is some work combining methods of theorem proving with certification
for verification intentions. However they are not carried out for vote counting.
On the other hand, in context of vote counting, merely few certifying algorithms
exist which are not accompanied by any verified checker.


The existing certificate-producing implemetations of vote counting
mainly formalise a voting protocol inside the Coq theorem prover
and then prove some desired properties about the formalised
specification, and then extract the development into Haskell or
OCaml programs.
Since the semantics of the target
and source of the extraction method differ, and there is no proof
that the translation occurs in a semantic-preserving way,
verification of the specification does not provably extend to
the extracted program. Moreover, these work are either not
accompanied by a checker\cite{DBLP:conf/voteid/GhaleGP17}, or their
checker is an unverified Haskell/OCaml
program\cite{DBLP:conf/itp/PattinsonT17}. One therefore has to trust
both 
the extraction mechanism and the compiler used to produce the
executable.


In the context of certified computation, 
Alkassar et
al~\cite{DBLP:journals/jar/AlkassarBMR14} combine certified
computation and theorem proving with methods of code verification to
establish a framework for validation of certifying algorithms in the
C programming language. 
With the help of the VCC
tool~\cite{DBLP:conf/icse/DahlweidMSTS09}, pre- and
postconditions are generated that are syntactically generalized in the Isabelle 
theorem prover to be discharged. The user has to trust the VCC tool, and there
is duplication of effort in that one has to generalise the
conditions imposed by the VCC and then implement them manually in
Isabelle to prove. To ameliorate this disadvantage, Noschinski et
al~\cite{DBLP:conf/nfm/NoschinskiRM14} replace the intermediate
step where VCC is invoked by the
AutoCorres~\cite{DBLP:conf/itp/GreenawayAK12} verifier which
provably correctly translates (part of) the C language into Isabelle in
a semantic preserving manner. Nonetheless one has to trust that the machine code behaviour correspondes to its top-level C encoding.



The community of e-voting verification agrees on encryption of votes cast before proceeding to tallying them. Then as a tallying verification step, they check if the encrypted votes cast appear correctly, with some zero-knowledge proofs if any, in the bulletin board~\cite{DBLP:journals/iacr/CortierGKMT16}. Many of them are essentially theoretical attempts in formulating protocols/systems that address verifiability conditons~\cite{DBLP:conf/ccs/KustersTV10,DBLP:journals/iacr/CortierGKMT16}. They also rely on pen-and-paper proofs to demonstrate validity of their framework~\cite{DBLP:conf/ccs/KustersTV10,DBLP:journals/iacr/CortierGKMT16,DBLP:conf/esorics/CortierGGI14,DBLP:conf/wote/JuelsCJ10,DBLP:conf/esorics/KremerRS10}. Some work~\cite{DBLP:conf/esorics/CortierGGI14} implement their algorithm in programming environments such as Python. However the algorithm, correctness proof of the algorithm, and the implementation occur in different unverified environments. Lack of any formal demonstration as why the three steps are provably correctly connected to one another, leaves a verfication, and subsequently trust, gap in their work. Cortier et al~\cite{DBLP:conf/post/CortierEKMW15} present simple formally stated pre- and post-conditions inside the dependently programming language $F^{\star}$. Their protocol concerns elections which allow voting for one candidate only. But more importantly, the environment $F^{\star}$ which they rely on, is implemented by a compiler that translates the syntax into RDCIL, a dialect of .NET bytecode. The compiler lacks verification of correct translation with respect to either semantic or syntax into the target domain. Therefore, one cannot guarantee the machine code would behave as the formalised counting protocol. Moreover, they call the external SAT solver Z3 to perform some computations. The mechanisms of these calls and whether they respect the semantic equivalences of computations obtained in different environments remains a question.  

%\vspace*{-0.1cm}
\section{Conclusion and Future Work}
Correct, publicly verifiable, transparent election count is a key
constituent of establishing trustworthiness in the final outcome. The tool developed here has clarity in encoding,
precision in formulation, and modularity in implementation so that it can be
taken as a framework for verifying STV election results down to machine level.

\bibliographystyle{splncs03}
\bibliography{paper,delta2,ev}
\end{document}
% vim: ft=tex
