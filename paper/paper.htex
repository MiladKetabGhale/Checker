\documentclass{llncs}
\usepackage{holtexbasic,url,amsmath,environ}
\renewcommand{\HOLinline}[1]{\ensuremath{#1}}
\renewcommand{\HOLKeyword}[1]{\mathsf{#1}}
\renewcommand{\HOLConst}[1]{{\textsf{\upshape #1}}}
\renewcommand{\HOLSymConst}[1]{\HOLConst{#1}}
\NewEnviron{holthmenv}{
  \begin{equation*}
  \begin{array}[t]{l}
  \BODY
  \end{array}
  \end{equation*}}
\newcommand{\TODO}[1]{{\bf TODO:} #1}
\begin{document}
\title{Verified Certificate Checking for Counting Votes}
\author{
Milad~K.~Ghale\inst{1}\and
Dirk~Pattison\inst{1}\and
Ramana~Kumar\inst{2}}
\institute{Australian National University\and
Data61, CSIRO and UNSW}
\maketitle
\begin{abstract}
Abstract goes here
\end{abstract}
\section{Introduction}\label{sec:intro}
Certified computation offers a high level of trustworthiness and correctness of the output end result. 
A Certifying program is an implementation of an algorithm which, upon each execution, produces an  end result accompanied by a certificate as to how it has been computed\cite{}. The certificate witnesses correctness of the computation and is independently and effectively checkable without any reference  to the program producing it. Therefore the verification objective directs to verifying the checker of the certificates rather than the program itself. In contrast to complete static verification methods, this demands much less resources for undertaking the task. Moreover, it considerably reduces the trust that clients has to lay in many components, including the programmer, compiler and hardware malfunctioning.



In recent years, numerous programs have come to carry the task of vote counting based on implementation of some Single Transferable Vote (STV) schemes. STV algorithms are preferential protocols for deciding winners of an election. They aim at reflecting the proportion of the preferences of the public towards different competing candidates. All of these programs are claimed to satisfy the expectations of the protocol. However, there are corner cases in STV protocols that are open to interpretation and, therefore, divergent implementations and computations. Moreover, source code of many of these programs are kept secret under the excuse of \lq\lq commercial in use\rq\rq\cite{} . This in addition to the mentioned difficulties of the traditional verification methods makes it challenging to verify these programs to decide which one(s) indeed implement the algorithm correctly. Hence, reliability of the computations by aforementioned programs requires huge amount of trust. Furthermore, absence of adequate correctness proofs stands in sharp contrast with election qualitative measures such as universal verifiability whose realisation amounts to providing as many scrutineers as possible with a guarantee for authenticity of the election result.

   

We approach each STV algorithm as a certified computation, where a certificate is produced upon each execution of an implementation of the algorithm. To validate the result, rather than verifying any particular implementation, we certify the certificate. To carry the task out, we formalise vote counting algorithm inside the theorem prover HOL as a sequence of logical rule applications to stages of the count.
Stages of the count, are formalised as typing judgements which are of two kind; non-final and final. The former is constituted of six components that put together provide all the necessary information to know what the current status of the count is. It informs the scrutineers of the ballots which (possibly) need to be counted, tally of each candidate, pile of the votes allocated to each candidate according to the preferences, list of candidates whose votes may be distributed later, and list of elected and continuing candidates at this stage. The latter judgement is a terminal stage of the process whereby winners of the election are
announced. 



The election protocol implicitly specifies steps for advancing the counting process. These steps which tell us when and how to move from one stage of the count (judgement) to another are formalised as logical rules. These rules have side conditions that must be met before such transitions can happen. Side conditions are, essentially, the formal counterpart of the protocol laid down by the legislation, and are expressed by standalone HOL predicates. By satisfying these side conditions, one makes sure that the process has proceeded in accordance to the protocol of the election. We shall refer to such assertions as predicative definitions or specification. We have another category of HOL assertions referred to as computational definitions. They correspond to some or one of the aforementioned predicative definitions. Conjunction of different, appropriate computational parts form the computational definition for each counting rule. By help of the equivalences established between components of the predicative counting rules and the computational ones, we come to verify that the computational rules meet the expectations of the specification, thus the protocol, at any application. 



A valid formal certificate is a list of judgements obtained by applications of counting rules. To check if a given formal certificate is valid, the checker merely
needs to verify if each two consecutive list elements match against a premise and conclusion of a legitimate rule instance application. Therefore, we formalise the
checker as a disjunction of computational counting rules. Finally, by invoking correspondences proven for each counting rule, a HOL proof guarantees that the checker validates a formal certificate if and only if the formal certificate is indeed valid.



\begin{itemize}
\item to do: write on connecting CakeML with HOL and the parser. Here we will explain proof of correspondence between valid certificates and valid judgements. The connection between checker as in HOL with loop function in CakeML. Some internal processes of translation from HOL to CakemL is to be given in a simple yet packed-up language.
\item
to do: tests of the executable. Here tests on the certificates output by counting programs is to be presented. The tests should reflect complexity of the computation with regards to number of ballots, candidates, and number of seats.
\item to do: reviewing related works. This one is almost right away. But will look to see if there is more to mention.
\end{itemize}



\section{Outline}\label{sec:out}

\noindent
Certificable / Verifiable Computation.
\begin{itemize}
  \item programs produce results with correctness proofs
  \item much easier than, and orthogonal to, verification
  \item however need to prove that valid certificates imply valid
  results (soundness), maybe also that every correct result is
  certifiable.
  \item in particular, this is independent of the program that
  produces the results.
  \item mainly used to offload computation to untrusted clients.
  \item reliability is given by verifying the \emph{checker} rather
  than the program that carries out computation.
\end{itemize}

\noindent
Vote counting.

\begin{itemize}
  \item here, we employ certified computation with a different goal:
  vote counting
  \item difference: general public / election authority is outsourcing
  computation to us.
  \item state of the art: no verifiability, black box, sometimes not
  even open source.
  \item this is a real problem -- e.g. NSW 2012 Griffith
  \item large trust base, including to trust that the right program
  has been run!
  \item indeed in evoting research: concept of ``universal
  verifiability'' means precisely that. Is the holy grail of any
  evoting system.
  \item for vote counting, this is a paradigm shift: don't verify
  the program, but verify the checker -- down to machine level!
  \item this happens in a fully verified / verifiable environment
  \item higher guarantees by machine level verification
\end{itemize}

\noindent
Our contribution.
\begin{itemize}
  \item Have formalised STV (complex, preferential voting scheme
  used in Malta, Scotland, etc.) in HOL
  \item rule based to minimise gap between law and code
  \item Have designed a notion of certificate that establishes the
  correctness of STV counts. Think about this more \dots
  \item Have developed a verified checker
  \item Used CakeML to give correctness down to machine level
  \item smallest possible trust base: microprocessor, basic IO
  system calls
\end{itemize}


\section{Single Transferable Vote and Certification}

\section{Final Theorem}
\begin{holthmenv}
  \HOLthm[width=80]{check_countProof.check_count_compiled_thm}
\end{holthmenv}

\begin{holthmenv}
  \HOLthm[def,width=90]{check_countProg.Check_Certificate_def}
\end{holthmenv}

\section{Evaluation}
\begin{itemize}
  \item to be done.
\end{itemize}

\section{Related Work}
\begin{itemize}
  \item Verifiability and electronic voting
  \item Verified / certified computation in general
  \item CakeML stuff??

\end{itemize}

\section{Conclusion}

\bibliographystyle{splncs03}
\bibliography{paper}
\end{document}
% vim: ft=tex
